module.exports = [
"[project]/node_modules/@neondatabase/auth/dist/constants-Cupc_bln.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "a",
    ()=>NEON_AUTH_POPUP_PARAM_NAME,
    "c",
    ()=>SESSION_CACHE_TTL_MS,
    "i",
    ()=>NEON_AUTH_POPUP_CALLBACK_ROUTE,
    "n",
    ()=>DEFAULT_SESSION_EXPIRY_MS,
    "o",
    ()=>NEON_AUTH_SESSION_VERIFIER_PARAM_NAME,
    "r",
    ()=>NEON_AUTH_POPUP_CALLBACK_PARAM_NAME,
    "s",
    ()=>OAUTH_POPUP_MESSAGE_TYPE,
    "t",
    ()=>CLOCK_SKEW_BUFFER_MS
]);
//#region src/core/constants.ts
/**
* Session caching configuration constants
*
* Uses industry-standard 60s cache TTL (common across auth providers).
*
* Note: Token refresh detection is now automatic via Better Auth's
* fetchOptions.onSuccess callback. No polling is needed.
*/ /** Session cache TTL in milliseconds (60 seconds) */ const SESSION_CACHE_TTL_MS = 6e4;
/** Clock skew buffer for token expiration checks in milliseconds (10 seconds) */ const CLOCK_SKEW_BUFFER_MS = 1e4;
/** Default session expiry duration in milliseconds (1 hour) */ const DEFAULT_SESSION_EXPIRY_MS = 36e5;
/** Name of the session verifier parameter in the URL, used for the OAUTH flow */ const NEON_AUTH_SESSION_VERIFIER_PARAM_NAME = "neon_auth_session_verifier";
/** Name of the popup marker parameter in the URL, used for OAuth popup flow in iframes */ const NEON_AUTH_POPUP_PARAM_NAME = "neon_popup";
/** Name of the original callback URL parameter, used in OAuth popup flow */ const NEON_AUTH_POPUP_CALLBACK_PARAM_NAME = "neon_popup_callback";
/** The callback route used for OAuth popup completion (must be in middleware SKIP_ROUTES) */ const NEON_AUTH_POPUP_CALLBACK_ROUTE = "/auth/callback";
/** Message type for OAuth popup completion postMessage */ const OAUTH_POPUP_MESSAGE_TYPE = "neon-auth:oauth-complete";
;
}),
"[project]/node_modules/@neondatabase/auth/dist/adapter-core-CtmnMMJ7.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "i",
    ()=>CURRENT_TAB_CLIENT_ID,
    "n",
    ()=>BETTER_AUTH_METHODS_CACHE,
    "r",
    ()=>BETTER_AUTH_METHODS_HOOKS,
    "t",
    ()=>NeonAuthAdapterCore
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/constants-Cupc_bln.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/client/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/proxy-DNjQepc2.mjs [app-ssr] (ecmascript) <export s as getGlobalBroadcastChannel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$plugins$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/client/plugins/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/index.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
//#region src/core/in-flight-request-manager.ts
/**
* Generic in-flight request deduplication manager.
*
* Prevents thundering herd by tracking Promises by key.
* Multiple concurrent calls with the same key await the same Promise
* instead of making N identical requests.
*
* Example:
* ```typescript
* const manager = new InFlightRequestManager();
*
* // 10 concurrent calls deduplicate to 1 actual fetch
* const results = await Promise.all([
*   manager.deduplicate('user:123', () => fetchUser(123)),
*   manager.deduplicate('user:123', () => fetchUser(123)),
*   // ... 8 more calls
* ]);
* // Result: 1 fetch call, 10 identical results
* ```
*
* Thread Safety: JavaScript is single-threaded, no race conditions possible
*/ var InFlightRequestManager = class {
    /**
	* Map of request keys to in-flight Promises.
	* Automatically cleared after Promise resolution (success or error).
	*/ inFlightRequests = /* @__PURE__ */ new Map();
    /**
	* Execute function with deduplication.
	*
	* If request with same key is in-flight, returns existing Promise.
	* Otherwise, executes fn and tracks the Promise.
	*
	* @param key - Unique identifier for this request (e.g., "getSession")
	* @param fn - Async function to execute (only called if no in-flight request exists)
	* @returns Promise that resolves to the function result
	*
	* @example
	* ```typescript
	* // First call: Executes fetchSession(), tracks Promise
	* const result1 = await manager.deduplicate('getSession', fetchSession);
	*
	* // Concurrent call: Returns existing Promise (no fetchSession() call)
	* const result2 = await manager.deduplicate('getSession', fetchSession);
	*
	* // Both results are identical (same object reference)
	* console.log(result1 === result2); // true
	* ```
	*/ async deduplicate(key, fn) {
        const existing = this.inFlightRequests.get(key);
        if (existing) return existing;
        const promise = fn().finally(()=>{
            this.inFlightRequests.delete(key);
        });
        this.inFlightRequests.set(key, promise);
        return promise;
    }
    /**
	* Clear specific in-flight request.
	*
	* Useful for forced refresh or cache invalidation scenarios.
	* Next call with same key will execute fresh request.
	*
	* @param key - Request key to clear
	*/ clear(key) {
        this.inFlightRequests.delete(key);
    }
    /**
	* Clear all in-flight requests.
	*
	* Useful for cleanup on sign-out or reset scenarios.
	*/ clearAll() {
        this.inFlightRequests.clear();
    }
    /**
	* Check if request is in-flight.
	*
	* @param key - Request key to check
	* @returns True if request is currently in-flight
	*/ has(key) {
        return this.inFlightRequests.has(key);
    }
    /**
	* Get count of in-flight requests (for debugging/testing).
	*
	* @returns Number of currently tracked requests
	*/ size() {
        return this.inFlightRequests.size;
    }
};
//#endregion
//#region src/utils/jwt.ts
/**
* Extract expiration timestamp from JWT payload
* @param jwt - The JWT token string
* @returns Expiration timestamp in seconds (Unix time) or null if invalid
*/ function getJwtExpiration(jwt) {
    try {
        const parts = jwt.split(".");
        if (parts.length !== 3) return null;
        const exp = JSON.parse(atob(parts[1])).exp;
        return typeof exp === "number" ? exp : null;
    } catch  {
        return null;
    }
}
//#endregion
//#region src/core/token-cache.ts
var TokenCache = class {
    cache = null;
    /**
	* Get cached data if not expired.
	* Returns null if cache is empty or expired.
	*/ get() {
        if (!this.cache) return null;
        if (Date.now() > this.cache.expiresAt) {
            this.cache = null;
            return null;
        }
        return this.cache.data;
    }
    /**
	* Set cached data with TTL.
	* If jwt is provided, TTL is calculated from its expiration.
	* Otherwise, uses default SESSION_CACHE_TTL_MS.
	*/ set(data, jwt) {
        const ttl = this.calculateTTL(jwt);
        this.cache = {
            data,
            expiresAt: Date.now() + ttl
        };
    }
    /**
	* Clear the cache.
	*/ clear() {
        this.cache = null;
    }
    /**
	* Check if cache has valid (non-expired) data.
	*/ has() {
        return this.get() !== null;
    }
    /**
	* Calculate cache TTL from JWT expiration.
	* Falls back to default TTL if JWT is invalid or missing.
	*/ calculateTTL(jwt) {
        if (!jwt) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"];
        const exp = getJwtExpiration(jwt);
        if (!exp) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"];
        const now = Date.now();
        const ttl = exp * 1e3 - now - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"];
        return Math.max(ttl, 1e3);
    }
};
//#endregion
//#region src/core/session-cache-manager.ts
/**
* Manages in-memory session cache with TTL expiration.
*
* Built on TokenCache, adding session-specific features:
* - Invalidation flag for sign-out scenarios
* - Token refresh detection via lastSessionData comparison
*
* Example:
* ```typescript
* const cacheManager = new SessionCacheManager();
* cacheManager.setCachedSession({ session, user });
* const cached = cacheManager.getCachedSession();
* ```
*/ var SessionCacheManager = class {
    cache = new TokenCache();
    lastSessionData = null;
    invalidated = false;
    /**
	* Get cached session if valid and not expired.
	* Returns null if cache is invalid, expired, or doesn't exist.
	*/ getCachedSession() {
        if (this.invalidated) return null;
        return this.cache.get();
    }
    /**
	* Set cached session with JWT-based TTL.
	* Skips caching if cache was invalidated (sign-out scenario).
	*/ setCachedSession(data) {
        if (this.invalidated) return;
        this.lastSessionData = this.cache.get();
        this.cache.set(data, data.session.token);
    }
    /**
	* Invalidate cache (marks as invalid but doesn't clear).
	* Useful for sign-out scenarios where in-flight requests should not cache.
	*/ invalidateSessionCache() {
        this.invalidated = true;
    }
    /**
	* Clear cache completely.
	*/ clearSessionCache() {
        this.cache.clear();
        this.lastSessionData = null;
        this.invalidated = false;
    }
    /**
	* Check if token was refreshed by comparing tokens with previous session.
	* Returns true if tokens differ (token was refreshed), false otherwise.
	*/ wasTokenRefreshed(data) {
        if (!this.lastSessionData?.session?.token || !data?.session?.token) return false;
        return this.lastSessionData.session.token !== data.session.token;
    }
};
//#endregion
//#region src/core/anonymous-token-cache-manager.ts
/**
* Manages in-memory anonymous token cache with TTL expiration.
*
* Stores the full anonymous token response (token + expires_at).
* Unlike SessionCacheManager, doesn't need:
* - Invalidation flag (no sign-out scenario for anonymous tokens)
* - Refresh detection (anonymous tokens are stateless)
*/ var AnonymousTokenCacheManager = class {
    cache = new TokenCache();
    /**
	* Get cached anonymous token response if not expired.
	* Returns null if cache is empty or expired.
	*/ getCachedResponse() {
        return this.cache.get();
    }
    /**
	* Set cached anonymous token response with JWT-based TTL.
	* TTL is automatically calculated from the JWT expiration.
	*/ setCachedResponse(data) {
        this.cache.set(data, data.token);
    }
    /**
	* Clear the cache.
	*/ clearCache() {
        this.cache.clear();
    }
    /**
	* Check if cache has a valid (non-expired) response.
	*/ hasCachedResponse() {
        return this.cache.has();
    }
};
//#endregion
//#region src/core/oauth-popup.ts
/**
* Opens an OAuth popup window and waits for completion.
*
* This is used when the app is running inside an iframe, where OAuth
* redirect flows don't work due to X-Frame-Options/CSP restrictions.
* The popup completes the OAuth flow and sends a postMessage back
* with the session verifier needed to fetch the session.
*
* @param url - The OAuth authorization URL to open in the popup
* @returns Promise that resolves with the session verifier when OAuth completes
* @throws Error if popup is blocked, closed by user, or times out
*/ async function openOAuthPopup(url) {
    const timeout = 12e4;
    const pollInterval = 500;
    return new Promise((resolve, reject)=>{
        const popup = globalThis.open(url, "neon_oauth_popup", "width=500,height=700,popup=yes");
        if (!popup || popup.closed) {
            reject(/* @__PURE__ */ new Error("Popup blocked. Please allow popups for this site."));
            return;
        }
        const timeoutId = setTimeout(()=>{
            cleanup();
            try {
                popup.close();
            } catch  {}
            reject(/* @__PURE__ */ new Error("OAuth popup timed out. Please try again."));
        }, timeout);
        const pollId = setInterval(()=>{
            try {
                if (popup.closed) {
                    cleanup();
                    reject(/* @__PURE__ */ new Error("OAuth popup was closed. Please try again."));
                }
            } catch  {}
        }, pollInterval);
        function cleanup() {
            clearTimeout(timeoutId);
            clearInterval(pollId);
            globalThis.removeEventListener("message", handleMessage);
        }
        function handleMessage(event) {
            if (event.origin !== globalThis.location.origin) return;
            if (event.data?.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]) return;
            cleanup();
            resolve({
                verifier: event.data.verifier || null
            });
        }
        globalThis.addEventListener("message", handleMessage);
    });
}
//#endregion
//#region src/utils/browser.ts
/**
* Checks if the code is running in a browser environment
* @returns true if in browser, false otherwise (e.g., Node.js)
*/ const isBrowser = ()=>{
    return globalThis.window !== void 0 && typeof document !== "undefined";
};
/**
* Checks if the code is running inside an iframe
* Used to detect embedded contexts where OAuth redirect won't work
* @returns true if in iframe, false otherwise
*/ const isIframe = ()=>{
    if (!isBrowser()) return false;
    try {
        return globalThis.self !== globalThis.top;
    } catch  {
        return true;
    }
};
//#endregion
//#region src/plugins/anonymous-token.ts
const ANONYMOUS_TOKEN_ENDPOINT = "/token/anonymous";
const anonymousTokenResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].object({
    token: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].string(),
    expires_at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"].number()
});
const anonymousTokenClient = ()=>{
    return {
        id: "anonymous-token",
        pathMethods: {
            [ANONYMOUS_TOKEN_ENDPOINT]: "GET"
        },
        getActions: ($fetch)=>{
            return {
                getAnonymousToken: async (fetchOptions)=>{
                    return await $fetch(ANONYMOUS_TOKEN_ENDPOINT, {
                        method: "GET",
                        ...fetchOptions
                    });
                }
            };
        }
    };
};
//#endregion
//#region src/core/better-auth-methods.ts
const CURRENT_TAB_CLIENT_ID = crypto.randomUUID();
const BETTER_AUTH_METHODS_IN_FLIGHT_REQUESTS = new InFlightRequestManager();
const BETTER_AUTH_METHODS_CACHE = new SessionCacheManager();
const BETTER_AUTH_ANONYMOUS_TOKEN_CACHE = new AnonymousTokenCacheManager();
const BETTER_AUTH_ENDPOINTS = {
    signUp: "/sign-up",
    signIn: "/sign-in",
    signOut: "/sign-out",
    updateUser: "/update-user",
    getSession: "/get-session",
    token: "/token",
    anonymousSignIn: "/sign-in/anonymous",
    anonymousToken: "/token/anonymous"
};
/**
* Handles social sign-in via popup when running inside an iframe.
* This is necessary because OAuth redirects don't work in iframes due to
* X-Frame-Options/CSP restrictions from OAuth providers.
*
* Flow:
* 1. Request OAuth URL from server (with disableRedirect)
* 2. Open popup window with the OAuth URL
* 3. Wait for popup to complete and send back the session verifier
* 4. Navigate to callbackURL with verifier - normal page load handles session
*/ async function handleSocialSignInViaPopup(input, init) {
    const body = JSON.parse(init?.body || "{}");
    const originalCallbackURL = body.callbackURL || "/";
    const popupCallbackUrl = new URL(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"], globalThis.location.origin);
    popupCallbackUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"], "1");
    popupCallbackUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"], originalCallbackURL);
    body.callbackURL = popupCallbackUrl.toString();
    body.disableRedirect = true;
    const response = await fetch(input, {
        ...init,
        body: JSON.stringify(body)
    });
    const data = await response.json();
    const oauthUrl = data.url;
    if (!oauthUrl) throw new Error("Failed to get OAuth URL");
    const popupResult = await openOAuthPopup(oauthUrl);
    if (!popupResult.verifier) throw new Error("OAuth completed but no session verifier received");
    const navigationUrl = new URL(originalCallbackURL, globalThis.location.origin);
    navigationUrl.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"], popupResult.verifier);
    globalThis.location.href = navigationUrl.toString();
    return Response.json(data, {
        status: response.status
    });
}
const BETTER_AUTH_METHODS_HOOKS = {
    signUp: {
        onRequest: ()=>{},
        onSuccess: (responseData)=>{
            if (isSessionResponseData(responseData)) {
                const sessionData = {
                    session: responseData.session,
                    user: responseData.user
                };
                BETTER_AUTH_METHODS_CACHE.setCachedSession(sessionData);
                emitAuthEvent({
                    type: "SIGN_IN",
                    data: sessionData
                });
            }
        }
    },
    signIn: {
        beforeFetch: (input, init)=>{
            if (!(typeof input === "string" ? input : input.toString()).includes("/sign-in/social") || !isIframe()) return null;
            return handleSocialSignInViaPopup(input, init);
        },
        onRequest: ()=>{},
        onSuccess: (responseData)=>{
            if (isSessionResponseData(responseData)) {
                const sessionData = {
                    session: responseData.session,
                    user: responseData.user
                };
                BETTER_AUTH_METHODS_CACHE.setCachedSession(sessionData);
                emitAuthEvent({
                    type: "SIGN_IN",
                    data: sessionData
                });
            }
        }
    },
    signOut: {
        onRequest: ()=>{
            BETTER_AUTH_METHODS_CACHE.invalidateSessionCache();
            BETTER_AUTH_METHODS_IN_FLIGHT_REQUESTS.clearAll();
        },
        onSuccess: ()=>{
            BETTER_AUTH_METHODS_CACHE.clearSessionCache();
            emitAuthEvent({
                type: "SIGN_OUT"
            });
        }
    },
    updateUser: {
        onRequest: ()=>{},
        onSuccess: (responseData)=>{
            if (isSessionResponseData(responseData)) {
                const sessionData = {
                    session: responseData.session,
                    user: responseData.user
                };
                BETTER_AUTH_METHODS_CACHE.setCachedSession(sessionData);
                emitAuthEvent({
                    type: "USER_UPDATE",
                    data: sessionData
                });
            } else {
                BETTER_AUTH_METHODS_CACHE.clearSessionCache();
                emitAuthEvent({
                    type: "USER_UPDATE"
                });
            }
        }
    },
    getSession: {
        beforeFetch: ()=>{
            const cachedData = BETTER_AUTH_METHODS_CACHE.getCachedSession();
            if (!cachedData) return null;
            return Response.json(cachedData, {
                status: 200
            });
        },
        onRequest: (ctx)=>{
            if (!isBrowser()) return;
            const neonAuthSessionVerifierParam = new URLSearchParams(globalThis.window.location.search).get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"]);
            if (neonAuthSessionVerifierParam) {
                const url = typeof ctx.url === "string" ? new URL(ctx.url) : ctx.url;
                url.searchParams.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"], neonAuthSessionVerifierParam);
                return {
                    ...ctx,
                    url
                };
            }
        },
        onSuccess: (responseData)=>{
            if (isSessionResponseData(responseData)) {
                const sessionData = {
                    session: responseData.session,
                    user: responseData.user
                };
                const wasRefreshed = BETTER_AUTH_METHODS_CACHE.wasTokenRefreshed(sessionData);
                BETTER_AUTH_METHODS_CACHE.setCachedSession(sessionData);
                if (wasRefreshed) emitAuthEvent({
                    type: "TOKEN_REFRESH",
                    data: sessionData
                });
                if (isBrowser()) {
                    const url = new URL(globalThis.window.location.href);
                    if (url.searchParams.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"])) {
                        url.searchParams.delete(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"]);
                        history.replaceState(history.state, "", url.href);
                    }
                }
            }
        }
    },
    anonymousToken: {
        beforeFetch: ()=>{
            const cachedResponse = BETTER_AUTH_ANONYMOUS_TOKEN_CACHE.getCachedResponse();
            if (!cachedResponse) return null;
            return Response.json(cachedResponse, {
                status: 200
            });
        },
        onRequest: ()=>{},
        onSuccess: (responseData)=>{
            const parsed = anonymousTokenResponseSchema.safeParse(responseData);
            if (parsed.success) BETTER_AUTH_ANONYMOUS_TOKEN_CACHE.setCachedResponse(parsed.data);
        }
    }
};
/**
* Unified event emission method that handles Better Auth broadcasts.
* Broadcasts use Better Auth native format - each adapter handles
* conversion to their specific format (e.g., Supabase Session).
*
* This ensures:
* - Single source of truth for all event emissions
* - Better Auth ecosystem compatibility via getGlobalBroadcastChannel()
* - Adapter-agnostic event format
* - Cross-tab synchronization via Better Auth's broadcast system
*/ async function emitAuthEvent(event) {
    const eventType = mapToEventType(event);
    const sessionData = "data" in event ? event.data : null;
    const trigger = mapToTrigger(event);
    if (trigger) (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__["getGlobalBroadcastChannel"])().post({
        event: "session",
        data: {
            trigger
        },
        clientId: CURRENT_TAB_CLIENT_ID
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__["getGlobalBroadcastChannel"])().post({
        event: "session",
        data: {
            trigger: eventType,
            sessionData
        },
        clientId: CURRENT_TAB_CLIENT_ID
    });
}
/** Maps internal event types to NeonAuthChangeEvent */ function mapToEventType(event) {
    switch(event.type){
        case "SIGN_IN":
            return "SIGNED_IN";
        case "SIGN_OUT":
            return "SIGNED_OUT";
        case "TOKEN_REFRESH":
            return "TOKEN_REFRESHED";
        case "USER_UPDATE":
            return "USER_UPDATED";
    }
}
/** Maps internal event types to Better Auth broadcast triggers */ function mapToTrigger(event) {
    switch(event.type){
        case "SIGN_OUT":
            return "signout";
        case "TOKEN_REFRESH":
            return null;
        case "USER_UPDATE":
            return "updateUser";
        case "SIGN_IN":
            return null;
    }
}
/**
* Type guard that validates response data has non-null session and user.
* Narrows the type to ensure session and user are not null.
*/ function isSessionResponseData(responseData) {
    return Boolean(responseData && typeof responseData === "object" && "session" in responseData && "user" in responseData && responseData.session !== null && responseData.user !== null);
}
function deriveBetterAuthMethodFromUrl(url) {
    if (url.includes("/sign-in/anonymous")) return "anonymousSignIn";
    if (url.includes(BETTER_AUTH_ENDPOINTS.anonymousToken)) return "anonymousToken";
    if (url.includes(BETTER_AUTH_ENDPOINTS.signIn)) return "signIn";
    if (url.includes(BETTER_AUTH_ENDPOINTS.signUp)) return "signUp";
    if (url.includes(BETTER_AUTH_ENDPOINTS.signOut)) return "signOut";
    if (url.includes(BETTER_AUTH_ENDPOINTS.updateUser)) return "updateUser";
    if (url.includes(BETTER_AUTH_ENDPOINTS.getSession) || url.includes(BETTER_AUTH_ENDPOINTS.token)) return "getSession";
}
function initBroadcastChannel() {
    if (isBrowser() && globalThis.opener && globalThis.opener !== globalThis) {
        const params = new URLSearchParams(globalThis.location.search);
        if (params.has(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])) {
            const verifier = params.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"]);
            const originalCallback = params.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]);
            globalThis.opener.postMessage({
                type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"],
                verifier,
                originalCallback
            }, "*");
            globalThis.close();
            return;
        }
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__["getGlobalBroadcastChannel"])().subscribe((message)=>{
        if (message.clientId === CURRENT_TAB_CLIENT_ID) return;
        const trigger = message.data?.trigger;
        if (trigger === "signout" || trigger === "updateUser" || trigger === "getSession") BETTER_AUTH_METHODS_CACHE.clearSessionCache();
    });
}
//#endregion
//#region package.json
var name = "@neondatabase/auth";
var version = "0.1.0-beta.21";
//#endregion
//#region ../internal/dist/index.mjs
const X_NEON_CLIENT_INFO_HEADER = "X-Neon-Client-Info";
/**
* Type guard for checking if a property exists on globalThis
*/ function hasGlobalProperty(key) {
    return key in globalThis;
}
/**
* Detects the JavaScript framework being used at runtime.
* Detection order matters to avoid false positives (e.g., Next.js includes React).
*/ function detectFramework() {
    if (typeof process !== "undefined" && process.env && (("TURBOPACK compile-time value", "nodejs") || process.env.__NEXT_PRIVATE_ORIGIN)) return "next";
    if (typeof globalThis.window !== "undefined") {
        if (hasGlobalProperty("__NEXT_DATA__")) return "next";
        if (hasGlobalProperty("__remixContext")) return "remix";
        if (hasGlobalProperty("__REACT_DEVTOOLS_GLOBAL_HOOK__")) return "react";
        if (hasGlobalProperty("__VUE__")) return "vue";
        if (hasGlobalProperty("Zone")) return "angular";
    }
}
function getClientInfo(sdkName, sdkVersion) {
    const base = {
        sdk: sdkName,
        version: sdkVersion,
        runtime: "unknown",
        runtimeVersion: "unknown",
        platform: "unknown",
        arch: "unknown"
    };
    let result;
    if (typeof process !== "undefined" && process.versions?.node) result = {
        ...base,
        runtime: "node",
        runtimeVersion: process.versions.node,
        platform: process.platform,
        arch: process.arch
    };
    else if (typeof Deno !== "undefined") result = {
        ...base,
        runtime: "deno",
        runtimeVersion: Deno.version?.deno ?? "unknown",
        platform: Deno.build?.os ?? "unknown",
        arch: Deno.build?.arch ?? "unknown"
    };
    else if (typeof Bun !== "undefined") result = {
        ...base,
        runtime: "bun",
        runtimeVersion: Bun.version ?? "unknown",
        platform: process?.platform ?? "unknown",
        arch: process?.arch ?? "unknown"
    };
    else if (typeof EdgeRuntime !== "undefined" || typeof process !== "undefined" && !process.versions?.node && typeof globalThis.window === "undefined" && typeof document === "undefined") result = {
        ...base,
        runtime: "edge"
    };
    else if (globalThis.window !== void 0 && typeof document !== "undefined") result = {
        ...base,
        runtime: "browser",
        runtimeVersion: "unknown",
        platform: "web",
        arch: "unknown"
    };
    else result = base;
    const framework = detectFramework();
    if (framework) result.framework = framework;
    return result;
}
function createClientInfoInjector(defaultSdkName, defaultSdkVersion) {
    const cachedClientInfo = JSON.stringify(getClientInfo(defaultSdkName, defaultSdkVersion));
    return function injectClientInfo$1(headers, sdkOverride) {
        const result = new Headers(headers);
        if (result.has(X_NEON_CLIENT_INFO_HEADER)) return result;
        const clientInfoString = sdkOverride ? JSON.stringify(getClientInfo(sdkOverride.name, sdkOverride.version)) : cachedClientInfo;
        result.set(X_NEON_CLIENT_INFO_HEADER, clientInfoString);
        return result;
    };
}
//#endregion
//#region src/utils/client-info.ts
const injectClientInfo = createClientInfoInjector(name, version);
//#endregion
//#region src/core/adapter-core.ts
const FORCE_FETCH_HEADER = "X-Force-Fetch";
const supportedBetterAuthClientPlugins = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$plugins$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jwtClient"])(),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$plugins$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["adminClient"])(),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$plugins$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["organizationClient"])(),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$plugins$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["emailOTPClient"])(),
    anonymousTokenClient()
];
var NeonAuthAdapterCore = class {
    betterAuthOptions;
    /**
	* Better Auth adapter implementing the NeonAuthClient interface.
	* See CLAUDE.md for architecture details and API mappings.
	*/ constructor(betterAuthClientOptions){
        const userOnSuccess = betterAuthClientOptions.fetchOptions?.onSuccess;
        const userOnRequest = betterAuthClientOptions.fetchOptions?.onRequest;
        this.betterAuthOptions = {
            ...betterAuthClientOptions,
            plugins: supportedBetterAuthClientPlugins,
            fetchOptions: {
                ...betterAuthClientOptions.fetchOptions,
                throw: false,
                onRequest: (request)=>{
                    const url = request.url;
                    const method = deriveBetterAuthMethodFromUrl(url.toString());
                    if (method) BETTER_AUTH_METHODS_HOOKS[method].onRequest(request);
                    userOnRequest?.(request);
                },
                customFetchImpl: async (url, init)=>{
                    const headers = injectClientInfo(init?.headers);
                    if (headers.has(FORCE_FETCH_HEADER)) {
                        headers.delete(FORCE_FETCH_HEADER);
                        const response$1 = await fetch(url, {
                            ...init,
                            headers
                        });
                        if (!response$1.ok) {
                            const body = await response$1.clone().json().catch(()=>({}));
                            const err = new Error(body.message || `HTTP ${response$1.status} ${response$1.statusText}`);
                            err.status = response$1.status;
                            err.statusText = response$1.statusText;
                            throw err;
                        }
                        return response$1;
                    }
                    const betterAuthMethod = deriveBetterAuthMethodFromUrl(url.toString());
                    if (betterAuthMethod) {
                        const response$1 = await BETTER_AUTH_METHODS_HOOKS[betterAuthMethod].beforeFetch?.(url, init);
                        if (response$1) return response$1;
                    }
                    const key = `${init?.method || "GET"}:${url}:${init?.body || ""}`;
                    const response = await BETTER_AUTH_METHODS_IN_FLIGHT_REQUESTS.deduplicate(key, ()=>fetch(url, {
                            ...init,
                            headers
                        }));
                    if (!response.ok) {
                        const errorBody = await response.clone().json().catch(()=>({}));
                        const err = new Error(errorBody.message || `HTTP ${response.status} ${response.statusText}`);
                        err.status = response.status;
                        err.statusText = response.statusText;
                        throw err;
                    }
                    return response.clone();
                },
                onSuccess: async (ctx)=>{
                    const jwt = ctx.response.headers.get("set-auth-jwt");
                    if (jwt) if (ctx.data?.session) ctx.data.session.token = jwt;
                    else console.warn("[onSuccess] JWT found but no session data to inject into!");
                    const url = ctx.request.url.toString();
                    const responseData = ctx.data;
                    const method = deriveBetterAuthMethodFromUrl(url);
                    if (method) BETTER_AUTH_METHODS_HOOKS[method].onSuccess(responseData);
                    await userOnSuccess?.(ctx);
                }
            }
        };
        initBroadcastChannel();
    }
    /**
	* Get JWT token for authenticated or anonymous access.
	* Single source of truth for token retrieval logic.
	*
	* @param allowAnonymous - When true, fetches anonymous token if no session exists
	* @returns JWT token string or null if unavailable
	*/ async getJWTToken(allowAnonymous) {
        const client = this.getBetterAuthInstance();
        const session = await client.getSession();
        if (session.data?.session?.token) return session.data.session.token;
        if (allowAnonymous) return (await client.getAnonymousToken()).data?.token ?? null;
        return null;
    }
};
;
}),
"[project]/node_modules/@neondatabase/auth/dist/better-auth-react-adapter-Dv-o6A6O.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "t",
    ()=>BetterAuthReactAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/adapter-core-CtmnMMJ7.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$react$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/client/react/index.mjs [app-ssr] (ecmascript)");
;
;
//#region src/adapters/better-auth-react/better-auth-react-adapter.ts
/**
* Internal implementation class - use BetterAuthReactAdapter factory function instead
*/ var BetterAuthReactAdapterImpl = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"] {
    _betterAuth;
    constructor(betterAuthClientOptions){
        super(betterAuthClientOptions);
        this._betterAuth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$react$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAuthClient"])(this.betterAuthOptions);
    }
    getBetterAuthInstance() {
        return this._betterAuth;
    }
};
/**
* Factory function that returns an adapter builder.
* The builder is called by createClient/createAuthClient with the URL.
*
* @param options - Optional adapter configuration (baseURL is injected separately)
* @returns A builder function that creates the adapter instance
*
* @example
* ```typescript
* const client = createClient({
*   auth: {
*     url: 'https://auth.example.com',
*     adapter: BetterAuthReactAdapter(),
*   },
*   dataApi: { url: 'https://data-api.example.com' },
* });
* ```
*/ function BetterAuthReactAdapter(options) {
    return (url, fetchOptions)=>new BetterAuthReactAdapterImpl({
            baseURL: url,
            ...options,
            fetchOptions: {
                ...options?.fetchOptions,
                headers: {
                    ...options?.fetchOptions?.headers,
                    ...fetchOptions?.headers
                }
            }
        });
}
;
}),
"[project]/node_modules/@neondatabase/auth/dist/supabase-adapter-BlcGPyOf.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "n",
    ()=>BetterAuthVanillaAdapter,
    "t",
    ()=>SupabaseAuthAdapter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/adapter-core-CtmnMMJ7.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/constants-Cupc_bln.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/client/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2d$BJRbyWu7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__r__as__createAuthClient$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/client-BJRbyWu7.mjs [app-ssr] (ecmascript) <export r as createAuthClient>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/better-auth/dist/proxy-DNjQepc2.mjs [app-ssr] (ecmascript) <export s as getGlobalBroadcastChannel>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/@supabase/auth-js/dist/module/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/node_modules/@supabase/auth-js/dist/module/lib/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$base64url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__base64url$3e$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/webapi/util/base64url.js [app-ssr] (ecmascript) <export * as base64url>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/webapi/util/decode_jwt.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$decode_protected_header$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jose/dist/webapi/util/decode_protected_header.js [app-ssr] (ecmascript)");
;
;
;
;
;
//#region src/adapters/better-auth-vanilla/better-auth-vanilla-adapter.ts
/**
* Internal implementation class - use BetterAuthVanillaAdapter factory function instead
*/ var BetterAuthVanillaAdapterImpl = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"] {
    _betterAuth;
    constructor(betterAuthClientOptions){
        super(betterAuthClientOptions);
        this._betterAuth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2d$BJRbyWu7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__r__as__createAuthClient$3e$__["createAuthClient"])(this.betterAuthOptions);
    }
    getBetterAuthInstance() {
        return this._betterAuth;
    }
};
/**
* Factory function that returns an adapter builder.
* The builder is called by createClient/createAuthClient with the URL.
*
* @param options - Optional adapter configuration (baseURL is injected separately)
* @returns A builder function that creates the adapter instance
*
* @example
* ```typescript
* const client = createClient({
*   auth: {
*     url: 'https://auth.example.com',
*     adapter: BetterAuthVanillaAdapter(),
*   },
*   dataApi: { url: 'https://data-api.example.com' },
* });
* ```
*/ function BetterAuthVanillaAdapter(options) {
    return (url, fetchOptions)=>new BetterAuthVanillaAdapterImpl({
            baseURL: url,
            ...options,
            fetchOptions: {
                ...options?.fetchOptions,
                headers: {
                    ...options?.fetchOptions?.headers,
                    ...fetchOptions?.headers
                }
            }
        });
}
//#endregion
//#region src/utils/date.ts
function toISOString(date) {
    if (!date) return /* @__PURE__ */ new Date().toISOString();
    if (typeof date === "string") return date;
    if (typeof date === "number") return new Date(date).toISOString();
    return date.toISOString();
}
//#endregion
//#region src/adapters/supabase/errors/definitions.ts
/**
* Error codes for type-safe error handling
*/ const AuthErrorCode = {
    BadJwt: "bad_jwt",
    InvalidCredentials: "invalid_credentials",
    SessionExpired: "session_expired",
    SessionNotFound: "session_not_found",
    InvalidGrant: "invalid_grant",
    UserNotFound: "user_not_found",
    UserAlreadyExists: "user_already_exists",
    EmailExists: "email_exists",
    PhoneExists: "phone_exists",
    EmailNotConfirmed: "email_not_confirmed",
    PhoneNotConfirmed: "phone_not_confirmed",
    ValidationFailed: "validation_failed",
    BadJson: "bad_json",
    WeakPassword: "weak_password",
    EmailAddressInvalid: "email_address_invalid",
    FeatureNotSupported: "feature_not_supported",
    NotImplemented: "not_implemented",
    OAuthProviderNotSupported: "oauth_provider_not_supported",
    PhoneProviderDisabled: "phone_provider_disabled",
    MagicLinkNotSupported: "magic_link_not_supported",
    SsoProviderDisabled: "sso_provider_disabled",
    AnonymousProviderDisabled: "anonymous_provider_disabled",
    Web3ProviderDisabled: "web3_provider_disabled",
    BadOAuthCallback: "bad_oauth_callback",
    OAuthCallbackFailed: "oauth_callback_failed",
    OverRequestRateLimit: "over_request_rate_limit",
    OverEmailSendRateLimit: "over_email_send_rate_limit",
    OverSmsSendRateLimit: "over_sms_send_rate_limit",
    UnexpectedFailure: "unexpected_failure",
    InternalError: "internal_error",
    IdentityNotFound: "identity_not_found",
    UnknownError: "unknown_error"
};
/**
* Complete error definitions map
* Maps error codes to HTTP status codes and default messages
*/ const ERROR_DEFINITIONS = {
    [AuthErrorCode.BadJwt]: {
        code: AuthErrorCode.BadJwt,
        status: 401,
        message: "Invalid or expired session token",
        description: "The JWT token is malformed, expired, or has an invalid signature"
    },
    [AuthErrorCode.InvalidCredentials]: {
        code: AuthErrorCode.InvalidCredentials,
        status: 401,
        message: "Invalid email or password",
        description: "The provided credentials do not match any user account"
    },
    [AuthErrorCode.SessionExpired]: {
        code: AuthErrorCode.SessionExpired,
        status: 401,
        message: "Session has expired",
        description: "The user session has exceeded its timeout period"
    },
    [AuthErrorCode.SessionNotFound]: {
        code: AuthErrorCode.SessionNotFound,
        status: 401,
        message: "No active session found",
        description: "The user does not have an active session or the session was invalidated"
    },
    [AuthErrorCode.InvalidGrant]: {
        code: AuthErrorCode.InvalidGrant,
        status: 401,
        message: "Invalid authorization grant",
        description: "OAuth/OIDC grant validation failed"
    },
    [AuthErrorCode.UserNotFound]: {
        code: AuthErrorCode.UserNotFound,
        status: 404,
        message: "User not found",
        description: "No user exists with the provided identifier"
    },
    [AuthErrorCode.UserAlreadyExists]: {
        code: AuthErrorCode.UserAlreadyExists,
        status: 409,
        message: "User already exists",
        description: "A user with this email or phone number is already registered"
    },
    [AuthErrorCode.EmailExists]: {
        code: AuthErrorCode.EmailExists,
        status: 409,
        message: "Email address already registered",
        description: "This email address is already associated with an account"
    },
    [AuthErrorCode.PhoneExists]: {
        code: AuthErrorCode.PhoneExists,
        status: 409,
        message: "Phone number already registered",
        description: "This phone number is already associated with an account"
    },
    [AuthErrorCode.EmailNotConfirmed]: {
        code: AuthErrorCode.EmailNotConfirmed,
        status: 422,
        message: "Email verification required",
        description: "The user must verify their email before signing in"
    },
    [AuthErrorCode.PhoneNotConfirmed]: {
        code: AuthErrorCode.PhoneNotConfirmed,
        status: 422,
        message: "Phone verification required",
        description: "The user must verify their phone number before signing in"
    },
    [AuthErrorCode.ValidationFailed]: {
        code: AuthErrorCode.ValidationFailed,
        status: 400,
        message: "Invalid request parameters",
        description: "One or more request parameters are invalid or missing"
    },
    [AuthErrorCode.BadJson]: {
        code: AuthErrorCode.BadJson,
        status: 400,
        message: "Invalid JSON in request body",
        description: "The request body contains malformed JSON"
    },
    [AuthErrorCode.WeakPassword]: {
        code: AuthErrorCode.WeakPassword,
        status: 400,
        message: "Password does not meet security requirements",
        description: "The password is too weak or does not meet complexity requirements"
    },
    [AuthErrorCode.EmailAddressInvalid]: {
        code: AuthErrorCode.EmailAddressInvalid,
        status: 400,
        message: "Invalid email address format",
        description: "The provided email address is not in a valid format"
    },
    [AuthErrorCode.FeatureNotSupported]: {
        code: AuthErrorCode.FeatureNotSupported,
        status: 403,
        message: "Feature not available",
        description: "This feature is not supported in the current configuration"
    },
    [AuthErrorCode.NotImplemented]: {
        code: AuthErrorCode.NotImplemented,
        status: 501,
        message: "Feature not implemented",
        description: "This feature has not been implemented yet"
    },
    [AuthErrorCode.OAuthProviderNotSupported]: {
        code: AuthErrorCode.OAuthProviderNotSupported,
        status: 403,
        message: "OAuth provider not supported",
        description: "The requested OAuth provider is not enabled"
    },
    [AuthErrorCode.PhoneProviderDisabled]: {
        code: AuthErrorCode.PhoneProviderDisabled,
        status: 403,
        message: "Phone authentication not available",
        description: "Phone number authentication is not enabled"
    },
    [AuthErrorCode.MagicLinkNotSupported]: {
        code: AuthErrorCode.MagicLinkNotSupported,
        status: 403,
        message: "Magic link authentication not available",
        description: "Magic link authentication is not supported"
    },
    [AuthErrorCode.SsoProviderDisabled]: {
        code: AuthErrorCode.SsoProviderDisabled,
        status: 403,
        message: "SSO not supported",
        description: "Enterprise SSO authentication is not available"
    },
    [AuthErrorCode.AnonymousProviderDisabled]: {
        code: AuthErrorCode.AnonymousProviderDisabled,
        status: 403,
        message: "Anonymous authentication not available",
        description: "Anonymous sign-in is not enabled"
    },
    [AuthErrorCode.Web3ProviderDisabled]: {
        code: AuthErrorCode.Web3ProviderDisabled,
        status: 403,
        message: "Web3 authentication not supported",
        description: "Web3/blockchain authentication is not available"
    },
    [AuthErrorCode.BadOAuthCallback]: {
        code: AuthErrorCode.BadOAuthCallback,
        status: 400,
        message: "Invalid OAuth callback",
        description: "The OAuth callback request is missing required parameters"
    },
    [AuthErrorCode.OAuthCallbackFailed]: {
        code: AuthErrorCode.OAuthCallbackFailed,
        status: 500,
        message: "OAuth authentication failed",
        description: "The OAuth callback completed but no session was created"
    },
    [AuthErrorCode.OverRequestRateLimit]: {
        code: AuthErrorCode.OverRequestRateLimit,
        status: 429,
        message: "Too many requests",
        description: "Rate limit exceeded. Please try again later"
    },
    [AuthErrorCode.OverEmailSendRateLimit]: {
        code: AuthErrorCode.OverEmailSendRateLimit,
        status: 429,
        message: "Too many email requests",
        description: "Too many emails sent. Please wait before trying again"
    },
    [AuthErrorCode.OverSmsSendRateLimit]: {
        code: AuthErrorCode.OverSmsSendRateLimit,
        status: 429,
        message: "Too many SMS requests",
        description: "Too many SMS messages sent. Please wait before trying again"
    },
    [AuthErrorCode.UnexpectedFailure]: {
        code: AuthErrorCode.UnexpectedFailure,
        status: 500,
        message: "An unexpected error occurred",
        description: "The server encountered an unexpected condition"
    },
    [AuthErrorCode.InternalError]: {
        code: AuthErrorCode.InternalError,
        status: 500,
        message: "Internal server error",
        description: "An internal error occurred while processing the request"
    },
    [AuthErrorCode.IdentityNotFound]: {
        code: AuthErrorCode.IdentityNotFound,
        status: 404,
        message: "Identity not found",
        description: "The requested user identity does not exist"
    },
    [AuthErrorCode.UnknownError]: {
        code: AuthErrorCode.UnknownError,
        status: 500,
        message: "An unknown error occurred",
        description: "The error could not be categorized"
    }
};
/**
* Helper to get error definition by code
*/ function getErrorDefinition(code) {
    return ERROR_DEFINITIONS[code];
}
/**
* Create an AuthError or AuthApiError with proper status and message
*
* @param code - The error code from AuthErrorCode
* @param customMessage - Optional custom message (defaults to error definition message)
* @returns AuthError for 5xx errors, AuthApiError for 4xx errors
*/ function createAuthError(code, customMessage) {
    const def = getErrorDefinition(code);
    const message = customMessage || def.message;
    const status = def.status;
    if (status !== 500 && status !== 501 && status !== 503) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AuthApiError"](message, status, def.code);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AuthError"](message, status, def.code);
}
//#endregion
//#region src/adapters/supabase/errors/mappings.ts
/**
* Maps Better Auth error codes to AuthErrorCode
* Based on Better Auth SDK error codes
*
* @see https://www.better-auth.com/docs/concepts/error-handling
*/ const BETTER_AUTH_ERROR_MAP = {
    "INVALID_EMAIL_OR_PASSWORD": AuthErrorCode.InvalidCredentials,
    "INVALID_PASSWORD": AuthErrorCode.InvalidCredentials,
    "INVALID_EMAIL": AuthErrorCode.EmailAddressInvalid,
    "USER_NOT_FOUND": AuthErrorCode.UserNotFound,
    "INVALID_TOKEN": AuthErrorCode.BadJwt,
    "SESSION_EXPIRED": AuthErrorCode.SessionExpired,
    "FAILED_TO_GET_SESSION": AuthErrorCode.SessionNotFound,
    "USER_ALREADY_EXISTS": AuthErrorCode.UserAlreadyExists,
    "EMAIL_NOT_VERIFIED": AuthErrorCode.EmailNotConfirmed,
    "USER_EMAIL_NOT_FOUND": AuthErrorCode.UserNotFound,
    "PASSWORD_TOO_SHORT": AuthErrorCode.WeakPassword,
    "PASSWORD_TOO_LONG": AuthErrorCode.WeakPassword,
    "USER_ALREADY_HAS_PASSWORD": AuthErrorCode.ValidationFailed,
    "CREDENTIAL_ACCOUNT_NOT_FOUND": AuthErrorCode.IdentityNotFound,
    "FAILED_TO_UNLINK_LAST_ACCOUNT": AuthErrorCode.ValidationFailed,
    "ACCOUNT_NOT_FOUND": AuthErrorCode.IdentityNotFound,
    "SOCIAL_ACCOUNT_ALREADY_LINKED": AuthErrorCode.ValidationFailed,
    "PROVIDER_NOT_FOUND": AuthErrorCode.OAuthProviderNotSupported,
    "ID_TOKEN_NOT_SUPPORTED": AuthErrorCode.FeatureNotSupported,
    "FAILED_TO_CREATE_USER": AuthErrorCode.InternalError,
    "FAILED_TO_CREATE_SESSION": AuthErrorCode.InternalError,
    "FAILED_TO_UPDATE_USER": AuthErrorCode.InternalError,
    "EMAIL_CAN_NOT_BE_UPDATED": AuthErrorCode.FeatureNotSupported
};
/**
* Maps HTTP status codes from Better Auth to AuthErrorCode
*/ const STATUS_CODE_ERROR_MAP = {
    400: AuthErrorCode.ValidationFailed,
    401: AuthErrorCode.BadJwt,
    403: AuthErrorCode.FeatureNotSupported,
    404: AuthErrorCode.UserNotFound,
    409: AuthErrorCode.UserAlreadyExists,
    422: AuthErrorCode.ValidationFailed,
    429: AuthErrorCode.OverRequestRateLimit,
    500: AuthErrorCode.UnexpectedFailure,
    501: AuthErrorCode.NotImplemented,
    503: AuthErrorCode.FeatureNotSupported
};
//#endregion
//#region src/core/better-auth-helpers.ts
/**
* Normalize Better Auth errors to standard AuthError format
*
* Handles three error formats:
* 1. BetterFetchError: { status, statusText, message?, code? }
* 2. BetterAuthErrorResponse: { status, statusText, message?, code? }
* 3. Standard Error: { message, name, stack }
*
* Maps Better Auth errors to appropriate AuthError/AuthApiError with:
* - Correct HTTP status codes
* - Standard error codes (snake_case)
* - User-friendly, security-conscious messages
*/ function normalizeBetterAuthError(error) {
    if (error !== null && error !== void 0 && typeof error === "object" && "status" in error && "statusText" in error) {
        const betterError = error;
        const status = betterError.status;
        if ("code" in betterError && betterError.code && typeof betterError.code === "string") {
            const mappedCode = BETTER_AUTH_ERROR_MAP[betterError.code];
            if (mappedCode) {
                const def$2 = getErrorDefinition(mappedCode);
                return createNormalizedError(def$2.message, def$2.status, def$2.code, status);
            }
        }
        const def$1 = getErrorDefinition(mapStatusCodeToErrorCode(status, betterError.message || betterError.statusText));
        return createNormalizedError(betterError.message || def$1.message, status, def$1.code, status);
    }
    if (error instanceof Error) {
        const def$1 = getErrorDefinition(mapMessageToErrorCode(error.message));
        return createNormalizedError(error.message || def$1.message, def$1.status, def$1.code, def$1.status);
    }
    const def = getErrorDefinition(AuthErrorCode.UnknownError);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AuthError"](def.message, def.status, def.code);
}
/**
* Map HTTP status code to AuthErrorCode
* Uses message content for disambiguation when status code is ambiguous
*/ function mapStatusCodeToErrorCode(status, message) {
    const lowerMessage = message?.toLowerCase() || "";
    switch(status){
        case 401:
            if (lowerMessage.includes("token") || lowerMessage.includes("jwt")) return AuthErrorCode.BadJwt;
            if (lowerMessage.includes("session")) return AuthErrorCode.SessionNotFound;
            if (lowerMessage.includes("expired")) return AuthErrorCode.SessionExpired;
            return AuthErrorCode.InvalidCredentials;
        case 404:
            if (lowerMessage.includes("identity") || lowerMessage.includes("account")) return AuthErrorCode.IdentityNotFound;
            if (lowerMessage.includes("session")) return AuthErrorCode.SessionNotFound;
            return AuthErrorCode.UserNotFound;
        case 409:
            if (lowerMessage.includes("email")) return AuthErrorCode.EmailExists;
            if (lowerMessage.includes("phone")) return AuthErrorCode.PhoneExists;
            return AuthErrorCode.UserAlreadyExists;
        case 422:
            if (lowerMessage.includes("email") && lowerMessage.includes("confirm")) return AuthErrorCode.EmailNotConfirmed;
            if (lowerMessage.includes("phone") && lowerMessage.includes("confirm")) return AuthErrorCode.PhoneNotConfirmed;
            return AuthErrorCode.ValidationFailed;
        case 429:
            if (lowerMessage.includes("email")) return AuthErrorCode.OverEmailSendRateLimit;
            if (lowerMessage.includes("sms") || lowerMessage.includes("phone")) return AuthErrorCode.OverSmsSendRateLimit;
            return AuthErrorCode.OverRequestRateLimit;
        case 400:
            if (lowerMessage.includes("password") && lowerMessage.includes("weak")) return AuthErrorCode.WeakPassword;
            if (lowerMessage.includes("email") && lowerMessage.includes("invalid")) return AuthErrorCode.EmailAddressInvalid;
            if (lowerMessage.includes("json")) return AuthErrorCode.BadJson;
            if (lowerMessage.includes("oauth") || lowerMessage.includes("callback")) return AuthErrorCode.BadOAuthCallback;
            return AuthErrorCode.ValidationFailed;
        case 403:
            if (lowerMessage.includes("provider") || lowerMessage.includes("oauth")) return AuthErrorCode.OAuthProviderNotSupported;
            if (lowerMessage.includes("phone")) return AuthErrorCode.PhoneProviderDisabled;
            if (lowerMessage.includes("sso")) return AuthErrorCode.SsoProviderDisabled;
            return AuthErrorCode.FeatureNotSupported;
        case 501:
            return AuthErrorCode.NotImplemented;
        case 503:
            return AuthErrorCode.FeatureNotSupported;
        default:
            if (lowerMessage.includes("oauth")) return AuthErrorCode.OAuthCallbackFailed;
            return AuthErrorCode.UnexpectedFailure;
    }
}
/**
* Map error message content to AuthErrorCode
* Used as fallback when status code is not available
*/ function mapMessageToErrorCode(message) {
    const lower = message.toLowerCase();
    if (lower.includes("invalid login") || lower.includes("incorrect") || lower.includes("wrong password")) return AuthErrorCode.InvalidCredentials;
    if (lower.includes("token") && (lower.includes("invalid") || lower.includes("expired"))) return AuthErrorCode.BadJwt;
    if (lower.includes("session") && lower.includes("expired")) return AuthErrorCode.SessionExpired;
    if (lower.includes("session") && lower.includes("not found")) return AuthErrorCode.SessionNotFound;
    if (lower.includes("already exists") || lower.includes("already registered")) return AuthErrorCode.UserAlreadyExists;
    if (lower.includes("not found") && lower.includes("user")) return AuthErrorCode.UserNotFound;
    if (lower.includes("not found") && lower.includes("identity")) return AuthErrorCode.IdentityNotFound;
    if (lower.includes("email") && lower.includes("not confirmed")) return AuthErrorCode.EmailNotConfirmed;
    if (lower.includes("phone") && lower.includes("not confirmed")) return AuthErrorCode.PhoneNotConfirmed;
    if (lower.includes("weak password") || lower.includes("password") && lower.includes("requirements")) return AuthErrorCode.WeakPassword;
    if (lower.includes("email") && lower.includes("invalid")) return AuthErrorCode.EmailAddressInvalid;
    if (lower.includes("rate limit") || lower.includes("too many requests")) return AuthErrorCode.OverRequestRateLimit;
    if (lower.includes("oauth") && lower.includes("failed")) return AuthErrorCode.OAuthCallbackFailed;
    if (lower.includes("provider") && lower.includes("not supported")) return AuthErrorCode.OAuthProviderNotSupported;
    return AuthErrorCode.UnexpectedFailure;
}
/**
* Create normalized error with correct type (AuthError vs AuthApiError)
* Uses AuthApiError for non-500 status codes (API/client errors)
* Uses AuthError for 500 status codes (server errors)
*/ function createNormalizedError(message, targetStatus, code, _originalStatus) {
    const status = targetStatus;
    if (status !== 500 && status !== 501 && status !== 503) return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AuthApiError"](message, status, code);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AuthError"](message, status, code);
}
/**
* Map Better Auth session to Session format
*/ function mapBetterAuthSession(betterAuthSession, betterAuthUser) {
    if (!betterAuthSession || !betterAuthUser) return null;
    let expiresAt;
    if (typeof betterAuthSession.expiresAt === "string") expiresAt = Math.floor(new Date(betterAuthSession.expiresAt).getTime() / 1e3);
    else if (typeof betterAuthSession.expiresAt === "object" && betterAuthSession.expiresAt instanceof Date) expiresAt = Math.floor(betterAuthSession.expiresAt.getTime() / 1e3);
    else expiresAt = Math.floor(Date.now() / 1e3) + Math.floor(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$constants$2d$Cupc_bln$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"] / 1e3);
    const now = Math.floor(Date.now() / 1e3);
    const expiresIn = Math.max(0, expiresAt - now);
    return {
        access_token: betterAuthSession.token,
        refresh_token: "",
        expires_at: expiresAt,
        expires_in: expiresIn,
        token_type: "bearer",
        user: mapBetterAuthUser(betterAuthUser)
    };
}
/**
* Map Better Auth user to User format
*/ function mapBetterAuthUser(betterAuthUser) {
    const createdAt = toISOString(betterAuthUser.createdAt);
    const updatedAt = toISOString(betterAuthUser.updatedAt);
    const userMetadata = {};
    if (betterAuthUser.name) userMetadata.displayName = betterAuthUser.name;
    if (betterAuthUser.image) userMetadata.profileImageUrl = betterAuthUser.image;
    const userRecord = betterAuthUser;
    for (const key of Object.keys(userRecord))if (![
        "id",
        "email",
        "emailVerified",
        "name",
        "image",
        "createdAt",
        "updatedAt"
    ].includes(key)) userMetadata[key] = userRecord[key];
    return {
        id: betterAuthUser.id,
        email: betterAuthUser.email || "",
        email_confirmed_at: betterAuthUser.emailVerified ? createdAt : void 0,
        phone: void 0,
        confirmed_at: betterAuthUser.emailVerified ? createdAt : void 0,
        last_sign_in_at: updatedAt,
        app_metadata: {},
        user_metadata: userMetadata,
        identities: [],
        created_at: createdAt,
        updated_at: updatedAt,
        aud: "authenticated",
        role: "authenticated"
    };
}
function mapBetterAuthIdentity(betterAuthUserIdentityAccount, accountInfoData) {
    return {
        id: betterAuthUserIdentityAccount.id,
        user_id: betterAuthUserIdentityAccount.id,
        identity_id: betterAuthUserIdentityAccount.accountId,
        provider: betterAuthUserIdentityAccount.providerId,
        created_at: toISOString(betterAuthUserIdentityAccount.createdAt),
        updated_at: toISOString(betterAuthUserIdentityAccount.updatedAt),
        last_sign_in_at: toISOString(betterAuthUserIdentityAccount.updatedAt),
        identity_data: accountInfoData ? {
            provider: betterAuthUserIdentityAccount.providerId,
            provider_id: betterAuthUserIdentityAccount.accountId,
            scopes: betterAuthUserIdentityAccount.scopes,
            email: accountInfoData.data.email,
            name: accountInfoData.data.user.name,
            picture: accountInfoData.data.user.picture,
            email_verified: accountInfoData.data.user.email_verified,
            ...accountInfoData.data
        } : {
            provider: betterAuthUserIdentityAccount.providerId,
            provider_id: betterAuthUserIdentityAccount.accountId,
            scopes: betterAuthUserIdentityAccount.scopes
        }
    };
}
//#endregion
//#region src/adapters/supabase/supabase-adapter.ts
/**
* Duck-type check for Better Auth API errors.
* Replaces `instanceof APIError` to avoid importing server-side code.
*/ function isBetterAuthAPIError(error) {
    return error !== null && typeof error === "object" && "status" in error && typeof error.status === "number";
}
/**
* Internal implementation class - use SupabaseAuthAdapter factory function instead
*/ var SupabaseAuthAdapterImpl = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"] {
    admin = void 0;
    mfa = void 0;
    oauth = void 0;
    _betterAuth;
    _stateChangeEmitters = /* @__PURE__ */ new Map();
    constructor(betterAuthClientOptions){
        super(betterAuthClientOptions);
        this._betterAuth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$client$2d$BJRbyWu7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__r__as__createAuthClient$3e$__["createAuthClient"])(this.betterAuthOptions);
        /**
		* useSession() - Automatic Session Management
		*
		* Enabled by Default:
		* -  Refetch on Window Focus: Automatically refetches session when user returns to the tab
		* -  Cross-Tab Sync: Syncs session state across all browser tabs (sign out in one = sign out in all)
		* -  Online/Offline Detection: Refetches session when network connection is restored
		* -  Interval Polling: Disabled (refetchInterval: 0)
		*
		* Returns:
		* - data: Session object (user + session)
		* - isPending: Loading state
		* - isRefetching: Refetch in progress
		* - error: Error object if any
		* - refetch(): Manual refetch function
		*
		* Customize with:
		* createAuthClient({
		*   sessionOptions: {
		*     refetchOnWindowFocus: true,  // default
		*     refetchInterval: 0,           // default (seconds, 0 = off)
		*     refetchWhenOffline: false     // default
		*   }
		* })
		*/ this._betterAuth.useSession.subscribe((value)=>{
            if (!value.data?.session || !value.data?.user) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"].clearSessionCache();
                return;
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f$better$2d$auth$2f$dist$2f$proxy$2d$DNjQepc2$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__s__as__getGlobalBroadcastChannel$3e$__["getGlobalBroadcastChannel"])().subscribe((message)=>{
            if (message.clientId === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"]) return;
            if (message.data && "sessionData" in message.data) {
                const sessionData = message.data.sessionData;
                const trigger = message.data.trigger;
                if (sessionData) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"].setCachedSession(sessionData);
                else __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"].clearSessionCache();
                const supabaseSession = sessionData ? mapBetterAuthSession(sessionData.session, sessionData.user) : null;
                const promises = [
                    ...this._stateChangeEmitters.values()
                ].map((subscription)=>{
                    try {
                        return Promise.resolve(subscription.callback(trigger, supabaseSession));
                    } catch  {
                        return Promise.resolve();
                    }
                });
                Promise.allSettled(promises);
            }
        });
    }
    getBetterAuthInstance() {
        return this._betterAuth;
    }
    initialize = async ()=>{
        try {
            const session = await this.getSession();
            if (session.error) throw session.error;
            return {
                data: session.data,
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    async getSession(options) {
        try {
            const currentSession = await this._betterAuth.getSession(options?.forceFetch ? {
                fetchOptions: {
                    headers: {
                        "X-Force-Fetch": "true"
                    }
                }
            } : void 0);
            if (!currentSession.data?.session) return {
                data: {
                    session: null
                },
                error: null
            };
            return {
                data: {
                    session: mapBetterAuthSession(currentSession.data.session, currentSession.data.user)
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    }
    refreshSession = async ()=>{
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.error) throw sessionResult.error;
            return {
                data: {
                    user: sessionResult.data.session?.user ?? null,
                    session: sessionResult.data.session
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    setSession = async ()=>{
        return {
            data: {
                user: null,
                session: null
            },
            error: createAuthError(AuthErrorCode.NotImplemented, "setSession() is not supported by Better Auth. Use signInWithPassword() instead.")
        };
    };
    signUp = async (credentials)=>{
        try {
            if ("email" in credentials && credentials.email && credentials.password) {
                const displayName = credentials.options?.data && "displayName" in credentials.options.data && typeof credentials.options.data.displayName === "string" ? credentials.options.data.displayName : "";
                const result = await this._betterAuth.signUp.email({
                    email: credentials.email,
                    password: credentials.password,
                    name: displayName,
                    callbackURL: credentials.options?.emailRedirectTo,
                    ...credentials.options?.data
                });
                if (result.error) throw normalizeBetterAuthError(result.error);
                const sessionResult = await this.getSession();
                if (!sessionResult.data.session?.user) throw createAuthError(AuthErrorCode.SessionNotFound, "Failed to retrieve user session");
                return {
                    data: {
                        user: sessionResult.data.session.user,
                        session: sessionResult.data.session
                    },
                    error: null
                };
            } else if ("phone" in credentials && credentials.phone) throw createAuthError(AuthErrorCode.PhoneProviderDisabled, "Phone sign-up not supported");
            else throw createAuthError(AuthErrorCode.ValidationFailed, "Invalid credentials format");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    signInAnonymously = async ()=>{
        return {
            data: {
                user: null,
                session: null
            },
            error: createAuthError(AuthErrorCode.AnonymousProviderDisabled, `Anonymous sign-in is not supported. To allow unauthenticated access with an anonymous JWT, use the allowAnonymous option in your Auth configuration instead.`)
        };
    };
    signInWithPassword = async (credentials)=>{
        try {
            if ("email" in credentials && credentials.email) {
                const result = await this._betterAuth.signIn.email({
                    email: credentials.email,
                    password: credentials.password
                });
                if (result.error) throw normalizeBetterAuthError(result.error);
                const sessionResult = await this.getSession();
                if (!sessionResult.data.session?.user) throw createAuthError(AuthErrorCode.SessionNotFound, "Failed to retrieve user session");
                return {
                    data: {
                        user: sessionResult.data.session.user,
                        session: sessionResult.data.session
                    },
                    error: null
                };
            } else if ("phone" in credentials && credentials.phone) throw createAuthError(AuthErrorCode.PhoneProviderDisabled, "Phone sign-in not supported");
            else throw createAuthError(AuthErrorCode.ValidationFailed, "Invalid credentials format");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    signInWithOAuth = async (credentials)=>{
        try {
            const { provider, options } = credentials;
            await this._betterAuth.signIn.social({
                provider,
                scopes: options?.scopes?.split(" "),
                disableRedirect: options?.skipBrowserRedirect,
                callbackURL: options?.redirectTo || (globalThis.window === void 0 ? "" : globalThis.location.origin)
            });
            return {
                data: {
                    provider,
                    url: options?.redirectTo || (globalThis.window === void 0 ? "" : globalThis.location.origin)
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    provider: credentials.provider,
                    url: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    provider: credentials.provider,
                    url: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    signInWithOtp = async (credentials)=>{
        try {
            if ("phone" in credentials) return {
                data: {
                    user: null,
                    session: null,
                    messageId: void 0
                },
                error: createAuthError(AuthErrorCode.PhoneProviderDisabled, "Phone OTP authentication is not supported. Use email-based authentication instead.")
            };
            if ("email" in credentials) {
                await this._betterAuth.emailOtp.sendVerificationOtp({
                    email: credentials.email,
                    type: "sign-in"
                });
                return {
                    data: {
                        user: null,
                        session: null,
                        messageId: void 0
                    },
                    error: null
                };
            }
            throw createAuthError(AuthErrorCode.ValidationFailed, "Invalid OTP credentials format");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null,
                    messageId: void 0
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null,
                    messageId: void 0
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    signInWithIdToken = async (credentials)=>{
        try {
            const result = await this._betterAuth.signIn.social({
                provider: credentials.provider,
                idToken: {
                    token: credentials.token,
                    accessToken: credentials.access_token,
                    nonce: credentials.nonce
                }
            });
            if (result.error) throw normalizeBetterAuthError(result.error);
            if (!("user" in result.data) || !result.data.user) throw createAuthError(AuthErrorCode.OAuthCallbackFailed, "Failed to sign in with ID token");
            const session = await this.getSession();
            if (session.error || !session.data.session) throw session.error || createAuthError(AuthErrorCode.SessionNotFound, "Failed to get session");
            return {
                data: {
                    user: session.data.session.user,
                    session: session.data.session
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    signInWithSSO = async (params)=>{
        const attemptedWith = "providerId" in params ? `provider ID: ${params.providerId}` : `domain: ${"domain" in params ? params.domain : "unknown"}`;
        return {
            data: null,
            error: createAuthError(AuthErrorCode.SsoProviderDisabled, `Better Auth does not support enterprise SAML SSO. Attempted with ${attemptedWith}. Use signInWithOAuth() for OAuth providers instead.`)
        };
    };
    signInWithWeb3 = async (credentials)=>{
        const attemptedChain = credentials.chain;
        return {
            data: {
                user: null,
                session: null
            },
            error: createAuthError(AuthErrorCode.Web3ProviderDisabled, `Better Auth does not support Web3 authentication. Attempted with chain: ${attemptedChain}. Supported: OAuth, email/password, magic link.`)
        };
    };
    signOut = async ()=>{
        try {
            const result = await this._betterAuth.signOut();
            if (result.error) throw normalizeBetterAuthError(result.error);
            return {
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                error
            };
            if (isBetterAuthAPIError(error)) return {
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    getUser = async ()=>{
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.error || !sessionResult.data.session) throw sessionResult.error || createAuthError(AuthErrorCode.SessionNotFound, "No user session found");
            return {
                data: {
                    user: sessionResult.data.session.user
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    getClaims = async (jwtArg)=>{
        try {
            let jwt = jwtArg;
            if (!jwt) {
                const sessionResult = await this.getSession();
                if (sessionResult.error || !sessionResult.data?.session) throw sessionResult.error || createAuthError(AuthErrorCode.SessionNotFound, "No user session found");
                jwt = sessionResult.data.session.access_token;
            }
            if (!jwt) throw createAuthError(AuthErrorCode.SessionNotFound, "No access token found");
            if (jwt.split(".").length !== 3) throw createAuthError(AuthErrorCode.BadJwt, "Invalid token format");
            return {
                data: {
                    header: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$decode_protected_header$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeProtectedHeader"])(jwt),
                    claims: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$decode_jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeJwt"])(jwt),
                    signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jose$2f$dist$2f$webapi$2f$util$2f$base64url$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__base64url$3e$__["base64url"].decode(jwt.split(".")[2])
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: null,
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: null,
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    updateUser = async (attributes)=>{
        try {
            if (attributes.password) throw createAuthError(AuthErrorCode.FeatureNotSupported, "The password cannot be updated through the updateUser method, use the changePassword method instead.");
            if (attributes.email) throw createAuthError(AuthErrorCode.FeatureNotSupported, "The email cannot be updated through the updateUser method, use the changeEmail method instead.");
            const result = await this._betterAuth.updateUser({
                ...attributes.data
            });
            if (result.data?.status) throw createAuthError(AuthErrorCode.InternalError, "Failed to update user");
            if (result?.error) throw normalizeBetterAuthError(result.error);
            const updatedSessionResult = await this.getSession({
                forceFetch: true
            });
            if (!updatedSessionResult.data.session) throw createAuthError(AuthErrorCode.SessionNotFound, "Failed to retrieve updated user");
            return {
                data: {
                    user: updatedSessionResult.data.session.user
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    getUserIdentities = async ()=>{
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.error || !sessionResult.data.session) throw sessionResult.error || createAuthError(AuthErrorCode.SessionNotFound, "No user session found");
            const result = await this._betterAuth.listAccounts();
            if (!result) throw createAuthError(AuthErrorCode.InternalError, "Failed to list accounts");
            if (result.error) throw normalizeBetterAuthError(result.error);
            const identitiesPromises = result.data.map(async (account)=>{
                let accountInfo = null;
                try {
                    accountInfo = (await this._betterAuth.accountInfo({
                        query: {
                            accountId: account.accountId
                        }
                    })).data;
                } catch (error) {
                    console.warn(`Failed to get account info for ${account.providerId}:`, error);
                }
                return mapBetterAuthIdentity(account, accountInfo ?? null);
            });
            return {
                data: {
                    identities: await Promise.all(identitiesPromises)
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: null,
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: null,
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    linkIdentity = async (credentials)=>{
        const provider = credentials.provider;
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.error || !sessionResult.data.session) throw sessionResult.error || createAuthError(AuthErrorCode.SessionNotFound, "No user session found");
            if ("token" in credentials) {
                const result$1 = await this._betterAuth.linkSocial({
                    provider,
                    idToken: {
                        token: credentials.token,
                        accessToken: credentials.access_token,
                        nonce: credentials.nonce
                    }
                });
                if (result$1.error) throw normalizeBetterAuthError(result$1.error);
                return {
                    data: {
                        user: sessionResult.data.session.user,
                        session: sessionResult.data.session,
                        provider,
                        url: result$1.data?.url
                    },
                    error: null
                };
            }
            const callbackURL = credentials.options?.redirectTo || (globalThis.window === void 0 ? "" : globalThis.location.origin);
            const scopes = credentials.options?.scopes?.split(" ").filter((s)=>s.length > 0);
            const result = await this._betterAuth.linkSocial({
                provider,
                callbackURL,
                errorCallbackURL: callbackURL ? `${callbackURL}?error=linking-failed` : void 0,
                scopes
            });
            if (result.error) throw normalizeBetterAuthError(result.error);
            return {
                data: {
                    provider,
                    url: result.data?.url,
                    user: sessionResult.data.session.user,
                    session: sessionResult.data.session
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    provider,
                    url: null,
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    provider,
                    url: null,
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    unlinkIdentity = async (identity)=>{
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.error || !sessionResult.data.session) throw sessionResult.error || createAuthError(AuthErrorCode.SessionNotFound, "No user session found");
            const identities = await this.getUserIdentities();
            if (identities.error || !identities.data) throw identities.error || createAuthError(AuthErrorCode.InternalError, "Failed to fetch identities");
            const targetIdentity = identities.data.identities.find((i)=>i.id === identity.identity_id);
            if (!targetIdentity) throw createAuthError(AuthErrorCode.IdentityNotFound, "Identity not found");
            const providerId = targetIdentity.provider;
            const accountId = targetIdentity.identity_id;
            const result = await this._betterAuth.unlinkAccount({
                providerId,
                accountId
            });
            if (result?.error) throw normalizeBetterAuthError(result.error);
            const updatedSession = await this.getSession({
                forceFetch: true
            });
            if (updatedSession.data.session) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]["updateUser"].onSuccess(updatedSession.data.session);
            return {
                data: {},
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: null,
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: null,
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    verifyOtp = async (params)=>{
        try {
            if ("phone" in params && params.phone) return {
                data: {
                    user: null,
                    session: null
                },
                error: createAuthError(AuthErrorCode.PhoneProviderDisabled, "Phone OTP verification is not supported. Use email-based authentication instead.")
            };
            if ("email" in params && params.type === "magiclink") return {
                data: {
                    user: null,
                    session: null
                },
                error: createAuthError(AuthErrorCode.MagicLinkNotSupported, "Magic link verification is not supported. Use email OTP authentication instead.")
            };
            if ("email" in params && params.email) return await this.verifyEmailOtp(params);
            if ("token_hash" in params && params.token_hash) throw createAuthError(AuthErrorCode.FeatureNotSupported, "Token hash verification not supported");
            throw createAuthError(AuthErrorCode.ValidationFailed, "Invalid OTP verification parameters");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    resetPasswordForEmail = async (email, options)=>{
        try {
            const result = await this._betterAuth.requestPasswordReset({
                email,
                redirectTo: options?.redirectTo || (globalThis.window === void 0 ? "" : globalThis.location.origin)
            });
            if (result?.error) throw normalizeBetterAuthError(result.error);
            return {
                data: {},
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: null,
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: null,
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    reauthenticate = async ()=>{
        try {
            const newSession = await this.getSession();
            if (newSession.error || !newSession.data.session) throw newSession.error || createAuthError(AuthErrorCode.SessionNotFound, "No session found");
            return {
                data: {
                    user: newSession.data.session?.user || null,
                    session: newSession.data.session
                },
                error: null
            };
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    resend = async (credentials)=>{
        try {
            if ("email" in credentials) {
                const { email, type, options } = credentials;
                if (type === "signup" || type === "email_change") {
                    const result = await this._betterAuth.sendVerificationEmail({
                        email,
                        callbackURL: options?.emailRedirectTo || (globalThis.window === void 0 ? "" : globalThis.location.origin)
                    });
                    if (result?.error) throw normalizeBetterAuthError(result.error);
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                }
                throw createAuthError(AuthErrorCode.ValidationFailed, `Unsupported resend type: ${type}`);
            }
            if ("phone" in credentials) return {
                data: {
                    user: null,
                    session: null
                },
                error: createAuthError(AuthErrorCode.PhoneProviderDisabled, "SMS resend is not supported. Use email-based authentication instead.")
            };
            throw createAuthError(AuthErrorCode.ValidationFailed, "Invalid credentials format");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    exchangeCodeForSession = async (_authCode)=>{
        try {
            const sessionResult = await this.getSession();
            if (sessionResult.data.session) return {
                data: {
                    session: sessionResult.data.session,
                    user: sessionResult.data.session.user
                },
                error: null
            };
            throw createAuthError(AuthErrorCode.OAuthCallbackFailed, "OAuth callback completed but no session was created. Make sure the OAuth callback has been processed.");
        } catch (error) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$node_modules$2f40$supabase$2f$auth$2d$js$2f$dist$2f$module$2f$lib$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAuthError"])(error)) return {
                data: {
                    session: null,
                    user: null
                },
                error
            };
            if (isBetterAuthAPIError(error)) return {
                data: {
                    session: null,
                    user: null
                },
                error: normalizeBetterAuthError(error)
            };
            throw error;
        }
    };
    onAuthStateChange = (callback)=>{
        const id = crypto.randomUUID();
        const subscription = {
            id,
            callback,
            unsubscribe: ()=>{
                this._stateChangeEmitters.delete(id);
            }
        };
        this._stateChangeEmitters.set(id, subscription);
        this.emitInitialSession(callback);
        return {
            data: {
                subscription: {
                    id,
                    callback,
                    unsubscribe: subscription.unsubscribe
                }
            }
        };
    };
    isThrowOnErrorEnabled = ()=>false;
    startAutoRefresh = async ()=>{};
    stopAutoRefresh = async ()=>{};
    async verifyEmailOtp(params) {
        const { type } = params;
        if (type === "email") {
            const result = await this._betterAuth.signIn.emailOtp({
                email: params.email,
                otp: params.token
            });
            if (result.error) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(result.error)
            };
            const sessionResult = await this.getSession({
                forceFetch: true
            });
            if (!sessionResult.data.session) return {
                data: {
                    user: null,
                    session: null
                },
                error: createAuthError(AuthErrorCode.SessionNotFound, "Failed to retrieve session after OTP verification. Make sure the magic link callback has been processed.")
            };
            return {
                data: {
                    user: sessionResult.data.session.user,
                    session: sessionResult.data.session
                },
                error: null
            };
        }
        if (type === "magiclink") return {
            data: {
                user: null,
                session: null
            },
            error: createAuthError(AuthErrorCode.MagicLinkNotSupported, "Magic link verification is not supported. Use email OTP authentication instead.")
        };
        if (type === "signup" || type === "invite") {
            const result = await this._betterAuth.emailOtp.verifyEmail({
                email: params.email,
                otp: params.token
            });
            if (result?.error) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(result.error)
            };
            const sessionResult = await this.getSession({
                forceFetch: true
            });
            return {
                data: {
                    user: sessionResult.data.session?.user ?? null,
                    session: sessionResult.data.session
                },
                error: null
            };
        }
        if (type === "recovery") {
            const checkResult = await this._betterAuth.emailOtp.checkVerificationOtp({
                email: params.email,
                otp: params.token,
                type: "forget-password"
            });
            if (checkResult.error || !checkResult.data?.success) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(checkResult.error)
            };
            return {
                data: {
                    user: null,
                    session: null
                },
                error: null
            };
        }
        if (type === "email_change") {
            const result = await this._betterAuth.verifyEmail({
                query: {
                    token: params.token,
                    callbackURL: params.options?.redirectTo
                }
            });
            if (result?.error) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(result.error)
            };
            const sessionResult = await this.getSession({
                forceFetch: true
            });
            if (sessionResult.error || !sessionResult.data) return {
                data: {
                    user: null,
                    session: null
                },
                error: sessionResult.error || createAuthError(AuthErrorCode.InternalError, "Failed to get session")
            };
            if (sessionResult.data.session) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$adapter$2d$core$2d$CtmnMMJ7$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]["updateUser"].onSuccess(sessionResult.data.session);
            return {
                data: {
                    user: sessionResult.data?.session?.user || null,
                    session: sessionResult.data?.session || null
                },
                error: null
            };
        }
        if (type === "invite") {
            const result = await this._betterAuth.organization.acceptInvitation({
                invitationId: params.token
            });
            if (result.error) return {
                data: {
                    user: null,
                    session: null
                },
                error: normalizeBetterAuthError(result.error)
            };
            const sessionResult = await this.getSession({
                forceFetch: true
            });
            if (sessionResult.error || !sessionResult.data) return {
                data: {
                    user: null,
                    session: null
                },
                error: sessionResult.error || createAuthError(AuthErrorCode.InternalError, "Failed to get session")
            };
            return {
                data: {
                    user: sessionResult.data?.session?.user || null,
                    session: sessionResult.data?.session
                },
                error: null
            };
        }
        return {
            data: {
                user: null,
                session: null
            },
            error: createAuthError(AuthErrorCode.ValidationFailed, `Unsupported email OTP type: ${type}`)
        };
    }
    async emitInitialSession(callback) {
        try {
            const { data, error } = await this.getSession();
            if (error) {
                await callback("INITIAL_SESSION", null);
                return;
            }
            await callback("INITIAL_SESSION", data.session);
        } catch  {
            await callback("INITIAL_SESSION", null);
        }
    }
};
/**
* Factory function that returns an adapter builder.
* The builder is called by createClient/createAuthClient with the URL.
*
* @param options - Optional adapter configuration (baseURL is injected separately)
* @returns A builder function that creates the adapter instance
*
* @example
* ```typescript
* const client = createClient({
*   auth: {
*     url: 'https://auth.example.com',
*     adapter: SupabaseAuthAdapter(),
*   },
*   dataApi: { url: 'https://data-api.example.com' },
* });
* ```
*/ function SupabaseAuthAdapter(options) {
    return (url, fetchOptions)=>new SupabaseAuthAdapterImpl({
            baseURL: url,
            ...options,
            fetchOptions: {
                ...options?.fetchOptions,
                headers: {
                    ...options?.fetchOptions?.headers,
                    ...fetchOptions?.headers
                }
            }
        });
}
;
}),
"[project]/node_modules/@neondatabase/auth/dist/neon-auth-Cs2cWh1B.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "n",
    ()=>createInternalNeonAuth,
    "t",
    ()=>createAuthClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$supabase$2d$adapter$2d$BlcGPyOf$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/supabase-adapter-BlcGPyOf.mjs [app-ssr] (ecmascript)");
;
//#region src/neon-auth.ts
/**
* Create a NeonAuth instance that exposes the appropriate API based on the adapter.
*
* @param url - The auth service URL (e.g., 'https://auth.example.com')
* @param config - Configuration with adapter builder
* @returns NeonAuth instance with the adapter's API exposed directly
*
* @example SupabaseAuthAdapter - Supabase-compatible API
* ```typescript
* import { createAuthClient, SupabaseAuthAdapter } from '@neondatabase/auth';
*
* const auth = createAuthClient('https://auth.example.com', {
*   adapter: SupabaseAuthAdapter(),
* });
*
* // Supabase-compatible methods
* await auth.signInWithPassword({ email, password });
* await auth.getSession();
* ```
*
* @example BetterAuthVanillaAdapter - Direct Better Auth API
* ```typescript
* import { createAuthClient, BetterAuthVanillaAdapter } from '@neondatabase/auth';
*
* const auth = createAuthClient('https://auth.example.com', {
*   adapter: BetterAuthVanillaAdapter(),
* });
*
* // Direct Better Auth API access
* await auth.signIn.email({ email, password });
* await auth.signUp.email({ email, password, name: 'John' });
* await auth.getSession();
* ```
*
* @example BetterAuthReactAdapter - Better Auth with React hooks
* ```typescript
* import { createAuthClient, BetterAuthReactAdapter } from '@neondatabase/auth';
*
* const auth = createAuthClient('https://auth.example.com', {
*   adapter: BetterAuthReactAdapter(),
* });
*
* // Direct Better Auth API with React hooks
* await auth.signIn.email({ email, password });
* const session = auth.useSession(); // React hook
* ```
*/ function createInternalNeonAuth(url, config) {
    const adapterBuilder = config?.adapter ?? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$supabase$2d$adapter$2d$BlcGPyOf$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])();
    const { fetchOptions } = config ?? {};
    const adapter = adapterBuilder(url, fetchOptions);
    const allowAnonymous = config?.allowAnonymous ?? false;
    if (!(typeof adapter.initialize === "function")) return {
        getJWTToken: ()=>adapter.getJWTToken(allowAnonymous),
        adapter: adapter.getBetterAuthInstance()
    };
    return {
        getJWTToken: ()=>adapter.getJWTToken(allowAnonymous),
        adapter
    };
}
function createAuthClient(url, config) {
    return createInternalNeonAuth(url, config).adapter;
}
;
}),
"[project]/node_modules/@neondatabase/auth/dist/next/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createAuthClient",
    ()=>createAuthClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$better$2d$auth$2d$react$2d$adapter$2d$Dv$2d$o6A6O$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/better-auth-react-adapter-Dv-o6A6O.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$neon$2d$auth$2d$Cs2cWh1B$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/neon-auth-Cs2cWh1B.mjs [app-ssr] (ecmascript)");
;
;
;
//#region src/next/index.ts
function createAuthClient() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$neon$2d$auth$2d$Cs2cWh1B$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"])(void 0, {
        adapter: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$better$2d$auth$2d$react$2d$adapter$2d$Dv$2d$o6A6O$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"])()
    });
}
;
}),
"[project]/node_modules/@neondatabase/auth/dist/chunk-VCZJYX65-CLnrj1o7-D6ZQkcc_.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "a",
    ()=>getLocalizedError,
    "c",
    ()=>getViewByPath,
    "i",
    ()=>cn,
    "l",
    ()=>isValidEmail,
    "n",
    ()=>authLocalization,
    "o",
    ()=>getPasswordSchema,
    "r",
    ()=>authViewPaths,
    "s",
    ()=>getSearchParam,
    "t",
    ()=>accountViewPaths,
    "u",
    ()=>organizationViewPaths
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/v4/classic/schemas.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/clsx/dist/clsx.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$bundle$2d$mjs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tailwind-merge/dist/bundle-mjs.mjs [app-ssr] (ecmascript)");
;
;
;
//#region ../auth-ui/dist/chunk-VCZJYX65-CLnrj1o7.mjs
function cn(...inputs) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tailwind$2d$merge$2f$dist$2f$bundle$2d$mjs$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["twMerge"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$clsx$2f$dist$2f$clsx$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clsx"])(inputs));
}
function isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
}
function getLocalizedError({ error, localization, localizeErrors = true }) {
    var _a;
    const DEFAULT_ERROR_MESSAGE = "Request failed";
    if (!localizeErrors) {
        if (error == null ? void 0 : error.message) return error.message;
        if ((_a = error == null ? void 0 : error.error) == null ? void 0 : _a.message) return error.error.message;
        return DEFAULT_ERROR_MESSAGE;
    }
    if (typeof error === "string") {
        if (localization == null ? void 0 : localization[error]) return localization[error];
    }
    if (error == null ? void 0 : error.error) {
        if (error.error.code) {
            const errorCode = error.error.code;
            if (localization == null ? void 0 : localization[errorCode]) return localization[errorCode];
        }
        return error.error.message || error.error.code || error.error.statusText || (localization == null ? void 0 : localization.REQUEST_FAILED);
    }
    return (error == null ? void 0 : error.message) || (localization == null ? void 0 : localization.REQUEST_FAILED) || DEFAULT_ERROR_MESSAGE;
}
function getSearchParam(paramName) {
    return ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : null;
}
function getViewByPath(viewPaths, path) {
    for(const key in viewPaths)if (viewPaths[key] === path) return key;
}
function getPasswordSchema(passwordValidation, localization) {
    let schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v4$2f$classic$2f$schemas$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["string"]().min(1, {
        message: localization == null ? void 0 : localization.PASSWORD_REQUIRED
    });
    if (passwordValidation == null ? void 0 : passwordValidation.minLength) schema = schema.min(passwordValidation.minLength, {
        message: localization == null ? void 0 : localization.PASSWORD_TOO_SHORT
    });
    if (passwordValidation == null ? void 0 : passwordValidation.maxLength) schema = schema.max(passwordValidation.maxLength, {
        message: localization == null ? void 0 : localization.PASSWORD_TOO_LONG
    });
    if (passwordValidation == null ? void 0 : passwordValidation.regex) schema = schema.regex(passwordValidation.regex, {
        message: localization == null ? void 0 : localization.INVALID_PASSWORD
    });
    return schema;
}
var ADMIN_ERROR_CODES = {
    FAILED_TO_CREATE_USER: "Failed to create user",
    USER_ALREADY_EXISTS: "User already exists",
    YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
    YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
    YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
    YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
    YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
    YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
    YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
    YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
    YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
    YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
    BANNED_USER: "You have been banned from this application"
};
var ANONYMOUS_ERROR_CODES = {
    FAILED_TO_CREATE_USER: "Failed to create user",
    COULD_NOT_CREATE_SESSION: "Could not create session",
    ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY: "Anonymous users cannot sign in again anonymously"
};
var API_KEY_ERROR_CODES = {
    INVALID_METADATA_TYPE: "metadata must be an object or undefined",
    REFILL_AMOUNT_AND_INTERVAL_REQUIRED: "refillAmount is required when refillInterval is provided",
    REFILL_INTERVAL_AND_AMOUNT_REQUIRED: "refillInterval is required when refillAmount is provided",
    USER_BANNED: "User is banned",
    UNAUTHORIZED_SESSION: "Unauthorized or invalid session",
    KEY_NOT_FOUND: "API Key not found",
    KEY_DISABLED: "API Key is disabled",
    KEY_EXPIRED: "API Key has expired",
    USAGE_EXCEEDED: "API Key has reached its usage limit",
    KEY_NOT_RECOVERABLE: "API Key is not recoverable",
    EXPIRES_IN_IS_TOO_SMALL: "The expiresIn is smaller than the predefined minimum value.",
    EXPIRES_IN_IS_TOO_LARGE: "The expiresIn is larger than the predefined maximum value.",
    INVALID_REMAINING: "The remaining count is either too large or too small.",
    INVALID_PREFIX_LENGTH: "The prefix length is either too large or too small.",
    INVALID_NAME_LENGTH: "The name length is either too large or too small.",
    METADATA_DISABLED: "Metadata is disabled.",
    RATE_LIMIT_EXCEEDED: "Rate limit exceeded.",
    NO_VALUES_TO_UPDATE: "No values to update.",
    KEY_DISABLED_EXPIRATION: "Custom key expiration values are disabled.",
    INVALID_API_KEY: "Invalid API key.",
    INVALID_USER_ID_FROM_API_KEY: "The user id from the API key is invalid.",
    INVALID_API_KEY_GETTER_RETURN_TYPE: "API Key getter returned an invalid key type. Expected string.",
    SERVER_ONLY_PROPERTY: "The property you're trying to set can only be set from the server auth instance only."
};
var BASE_ERROR_CODES = {
    USER_NOT_FOUND: "User not found",
    FAILED_TO_CREATE_USER: "Failed to create user",
    FAILED_TO_CREATE_SESSION: "Failed to create session",
    FAILED_TO_UPDATE_USER: "Failed to update user",
    FAILED_TO_GET_SESSION: "Failed to get session",
    INVALID_PASSWORD: "Invalid password",
    INVALID_EMAIL: "Invalid email",
    INVALID_EMAIL_OR_PASSWORD: "Invalid email or password",
    SOCIAL_ACCOUNT_ALREADY_LINKED: "Social account already linked",
    PROVIDER_NOT_FOUND: "Provider not found",
    INVALID_TOKEN: "Invalid token",
    ID_TOKEN_NOT_SUPPORTED: "id_token not supported",
    FAILED_TO_GET_USER_INFO: "Failed to get user info",
    USER_EMAIL_NOT_FOUND: "User email not found",
    EMAIL_NOT_VERIFIED: "Email not verified",
    PASSWORD_TOO_SHORT: "Password too short",
    PASSWORD_TOO_LONG: "Password too long",
    USER_ALREADY_EXISTS: "User already exists",
    EMAIL_CAN_NOT_BE_UPDATED: "Email can not be updated",
    CREDENTIAL_ACCOUNT_NOT_FOUND: "Credential account not found",
    SESSION_EXPIRED: "Session expired. Re-authenticate to perform this action.",
    FAILED_TO_UNLINK_LAST_ACCOUNT: "You can't unlink your last account",
    ACCOUNT_NOT_FOUND: "Account not found",
    USER_ALREADY_HAS_PASSWORD: "User already has a password. Provide that to delete the account."
};
var EXTERNAL_ERROR_CODES = {
    VERIFICATION_FAILED: "Captcha verification failed",
    MISSING_RESPONSE: "Missing CAPTCHA response",
    UNKNOWN_ERROR: "Something went wrong"
};
var INTERNAL_ERROR_CODES = {
    MISSING_SECRET_KEY: "Missing secret key",
    SERVICE_UNAVAILABLE: "CAPTCHA service unavailable"
};
var CAPTCHA_ERROR_CODES = {
    ...EXTERNAL_ERROR_CODES,
    ...INTERNAL_ERROR_CODES
};
var EMAIL_OTP_ERROR_CODES = {
    OTP_EXPIRED: "otp expired",
    INVALID_OTP: "Invalid OTP",
    INVALID_EMAIL: "Invalid email",
    USER_NOT_FOUND: "User not found",
    TOO_MANY_ATTEMPTS: "Too many attempts"
};
var GENERIC_OAUTH_ERROR_CODES = {
    INVALID_OAUTH_CONFIGURATION: "Invalid OAuth configuration"
};
var HAVEIBEENPWNED_ERROR_CODES = {
    PASSWORD_COMPROMISED: "The password you entered has been compromised. Please choose a different password."
};
var MULTI_SESSION_ERROR_CODES = {
    INVALID_SESSION_TOKEN: "Invalid session token"
};
var ORGANIZATION_ERROR_CODES = {
    YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION: "You are not allowed to create a new organization",
    YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS: "You have reached the maximum number of organizations",
    ORGANIZATION_ALREADY_EXISTS: "Organization already exists",
    ORGANIZATION_NOT_FOUND: "Organization not found",
    USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION: "User is not a member of the organization",
    YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION: "You are not allowed to update this organization",
    YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION: "You are not allowed to delete this organization",
    NO_ACTIVE_ORGANIZATION: "No active organization",
    USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION: "User is already a member of this organization",
    MEMBER_NOT_FOUND: "Member not found",
    ROLE_NOT_FOUND: "Role not found",
    YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM: "You are not allowed to create a new team",
    TEAM_ALREADY_EXISTS: "Team already exists",
    TEAM_NOT_FOUND: "Team not found",
    YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER: "You cannot leave the organization as the only owner",
    YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER: "You are not allowed to delete this member",
    YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION: "You are not allowed to invite users to this organization",
    USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION: "User is already invited to this organization",
    INVITATION_NOT_FOUND: "Invitation not found",
    YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION: "You are not the recipient of the invitation",
    YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION: "You are not allowed to cancel this invitation",
    INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION: "Inviter is no longer a member of the organization",
    YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE: "you are not allowed to invite user with this role",
    FAILED_TO_RETRIEVE_INVITATION: "Failed to retrieve invitation",
    YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS: "You have reached the maximum number of teams",
    UNABLE_TO_REMOVE_LAST_TEAM: "Unable to remove last team",
    YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER: "You are not allowed to update this member",
    ORGANIZATION_MEMBERSHIP_LIMIT_REACHED: "Organization membership limit reached",
    YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to create teams in this organization",
    YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to delete teams in this organization",
    YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM: "You are not allowed to update this team",
    YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM: "You are not allowed to delete this team",
    INVITATION_LIMIT_REACHED: "Invitation limit reached"
};
var PASSKEY_ERROR_CODES = {
    CHALLENGE_NOT_FOUND: "Challenge not found",
    YOU_ARE_NOT_ALLOWED_TO_REGISTER_THIS_PASSKEY: "You are not allowed to register this passkey",
    FAILED_TO_VERIFY_REGISTRATION: "Failed to verify registration",
    PASSKEY_NOT_FOUND: "Passkey not found",
    AUTHENTICATION_FAILED: "Authentication failed",
    UNABLE_TO_CREATE_SESSION: "Unable to create session",
    FAILED_TO_UPDATE_PASSKEY: "Failed to update passkey"
};
var PHONE_NUMBER_ERROR_CODES = {
    INVALID_PHONE_NUMBER: "Invalid phone number",
    PHONE_NUMBER_EXIST: "Phone number already exists",
    INVALID_PHONE_NUMBER_OR_PASSWORD: "Invalid phone number or password",
    UNEXPECTED_ERROR: "Unexpected error",
    OTP_NOT_FOUND: "OTP not found",
    OTP_EXPIRED: "OTP expired",
    INVALID_OTP: "Invalid OTP",
    PHONE_NUMBER_NOT_VERIFIED: "Phone number not verified"
};
var STRIPE_ERROR_CODES = {
    SUBSCRIPTION_NOT_FOUND: "Subscription not found",
    SUBSCRIPTION_PLAN_NOT_FOUND: "Subscription plan not found",
    ALREADY_SUBSCRIBED_PLAN: "You're already subscribed to this plan",
    UNABLE_TO_CREATE_CUSTOMER: "Unable to create customer",
    FAILED_TO_FETCH_PLANS: "Failed to fetch plans",
    EMAIL_VERIFICATION_REQUIRED: "Email verification is required before you can subscribe to a plan",
    SUBSCRIPTION_NOT_ACTIVE: "Subscription is not active",
    SUBSCRIPTION_NOT_SCHEDULED_FOR_CANCELLATION: "Subscription is not scheduled for cancellation"
};
var TEAM_ERROR_CODES = {
    TEAM_LIMIT_REACHED: "Team limit reached for this organization",
    TEAM_MEMBER_LIMIT_REACHED: "Team member limit reached for this team",
    TEAM_NOT_FOUND: "Team not found",
    TEAM_MEMBER_NOT_FOUND: "Team member not found",
    TEAM_NAME_TOO_LONG: "Team name is too long",
    CANNOT_REMOVE_LAST_TEAM: "Cannot remove the last team",
    NOT_ORGANIZATION_MEMBER: "User is not a member of the organization",
    ALREADY_TEAM_MEMBER: "User is already a member of this team",
    INSUFFICIENT_TEAM_PERMISSIONS: "Insufficient permissions to perform this action on team"
};
var TWO_FACTOR_ERROR_CODES = {
    OTP_NOT_ENABLED: "OTP not enabled",
    OTP_HAS_EXPIRED: "OTP has expired",
    TOTP_NOT_ENABLED: "TOTP not enabled",
    TWO_FACTOR_NOT_ENABLED: "Two factor isn't enabled",
    BACKUP_CODES_NOT_ENABLED: "Backup codes aren't enabled",
    INVALID_BACKUP_CODE: "Invalid backup code",
    INVALID_CODE: "Invalid code",
    TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE: "Too many attempts. Please request a new code.",
    INVALID_TWO_FACTOR_COOKIE: "Invalid two factor cookie"
};
var USERNAME_ERROR_CODES = {
    INVALID_USERNAME_OR_PASSWORD: "invalid username or password",
    EMAIL_NOT_VERIFIED: "email not verified",
    UNEXPECTED_ERROR: "unexpected error",
    USERNAME_IS_ALREADY_TAKEN: "username is already taken. please try another.",
    USERNAME_TOO_SHORT: "username is too short",
    USERNAME_TOO_LONG: "username is too long",
    INVALID_USERNAME: "username is invalid"
};
var authLocalization = {
    APP: "App",
    ACCOUNT: "Account",
    ACCOUNTS: "Accounts",
    ACCOUNTS_DESCRIPTION: "Switch between your currently signed in accounts.",
    ACCOUNTS_INSTRUCTIONS: "Sign in to an additional account.",
    ADD_ACCOUNT: "Add Account",
    ADD_PASSKEY: "Add Passkey",
    ALREADY_HAVE_AN_ACCOUNT: "Already have an account?",
    AVATAR: "Avatar",
    AVATAR_DESCRIPTION: "Click on the avatar to upload a custom one from your files.",
    AVATAR_INSTRUCTIONS: "An avatar is optional but strongly recommended.",
    BACKUP_CODE_REQUIRED: "Backup code is required",
    BACKUP_CODES: "Backup Codes",
    BACKUP_CODES_DESCRIPTION: "Save these backup codes in a secure place. You can use them to access your account if you lose your two-factor authentication method.",
    BACKUP_CODE_PLACEHOLDER: "Backup Code",
    BACKUP_CODE: "Backup Code",
    CANCEL: "Cancel",
    CHANGE_PASSWORD: "Change Password",
    CHANGE_PASSWORD_DESCRIPTION: "Enter your current password and a new password.",
    CHANGE_PASSWORD_INSTRUCTIONS: "Please use 8 characters at minimum.",
    CHANGE_PASSWORD_SUCCESS: "Your password has been changed.",
    CONFIRM_PASSWORD: "Confirm Password",
    CONFIRM_PASSWORD_PLACEHOLDER: "Confirm Password",
    CONFIRM_PASSWORD_REQUIRED: "Confirm password is required",
    CONTINUE_WITH_AUTHENTICATOR: "Continue with Authenticator",
    COPIED_TO_CLIPBOARD: "Copied to clipboard",
    COPY_TO_CLIPBOARD: "Copy to clipboard",
    COPY_ALL_CODES: "Copy all codes",
    CONTINUE: "Continue",
    CURRENT_PASSWORD: "Current Password",
    CURRENT_PASSWORD_PLACEHOLDER: "Current Password",
    CURRENT_SESSION: "Current Session",
    UPDATE: "Update",
    DELETE: "Delete",
    DELETE_AVATAR: "Delete Avatar",
    DELETE_ACCOUNT: "Delete Account",
    DELETE_ACCOUNT_DESCRIPTION: "Permanently remove your account and all of its contents. This action is not reversible, so please continue with caution.",
    DELETE_ACCOUNT_INSTRUCTIONS: "Please confirm the deletion of your account. This action is not reversible, so please continue with caution.",
    DELETE_ACCOUNT_VERIFY: "Please check your email to verify the deletion of your account.",
    DELETE_ACCOUNT_SUCCESS: "Your account has been deleted.",
    DISABLE_TWO_FACTOR: "Disable Two-Factor",
    DISABLED_CREDENTIALS_DESCRIPTION: "Choose a provider to login to your account",
    DONT_HAVE_AN_ACCOUNT: "Don't have an account?",
    DONE: "Done",
    EMAIL: "Email",
    EMAIL_DESCRIPTION: "Enter the email address you want to use to log in.",
    EMAIL_INSTRUCTIONS: "Please enter a valid email address.",
    EMAIL_IS_THE_SAME: "Email is the same",
    EMAIL_PLACEHOLDER: "m@example.com",
    EMAIL_REQUIRED: "Email address is required",
    EMAIL_VERIFY_CHANGE: "Please check your email to verify the change.",
    EMAIL_VERIFICATION: "Please check your email for the verification link.",
    ENABLE_TWO_FACTOR: "Enable Two-Factor",
    IS_INVALID: "is invalid",
    IS_REQUIRED: "is required",
    IS_THE_SAME: "is the same",
    FORGOT_AUTHENTICATOR: "Forgot authenticator?",
    FORGOT_PASSWORD: "Forgot Password",
    FORGOT_PASSWORD_ACTION: "Send reset link",
    FORGOT_PASSWORD_DESCRIPTION: "Enter your email to reset your password",
    FORGOT_PASSWORD_EMAIL: "Check your email for the password reset link.",
    FORGOT_PASSWORD_LINK: "Forgot your password?",
    LINK: "Link",
    MAGIC_LINK: "Magic Link",
    MAGIC_LINK_ACTION: "Send magic link",
    MAGIC_LINK_DESCRIPTION: "Enter your email to receive a magic link",
    MAGIC_LINK_EMAIL: "Check your email for the magic link",
    EMAIL_OTP: "Email Code",
    EMAIL_OTP_SEND_ACTION: "Send code",
    EMAIL_OTP_VERIFY_ACTION: "Verify code",
    EMAIL_OTP_DESCRIPTION: "Enter your email to receive a code",
    EMAIL_OTP_VERIFICATION_SENT: "Please check your email for the verification code.",
    NAME: "Name",
    NAME_DESCRIPTION: "Please enter your full name, or a display name.",
    NAME_INSTRUCTIONS: "Please use 32 characters at maximum.",
    NAME_PLACEHOLDER: "Name",
    NEW_PASSWORD: "New Password",
    NEW_PASSWORD_PLACEHOLDER: "New Password",
    NEW_PASSWORD_REQUIRED: "New password is required",
    ONE_TIME_PASSWORD: "One-Time Password",
    OR_CONTINUE_WITH: "Or continue with",
    PASSKEY: "Passkey",
    PASSKEYS: "Passkeys",
    PASSKEYS_DESCRIPTION: "Manage your passkeys for secure access.",
    PASSKEYS_INSTRUCTIONS: "Securely access your account without a password.",
    PERSONAL_ACCOUNT: "Personal Account",
    API_KEYS: "API Keys",
    API_KEYS_DESCRIPTION: "Manage your API keys for secure access.",
    API_KEYS_INSTRUCTIONS: "Generate API keys to access your account programmatically.",
    CREATE_API_KEY: "Create API Key",
    CREATE_API_KEY_DESCRIPTION: "Enter a unique name for your API key to differentiate it from other keys.",
    API_KEY_NAME_PLACEHOLDER: "New API Key",
    API_KEY_CREATED: "API Key Created",
    CREATE_API_KEY_SUCCESS: "Please copy your API key and store it in a safe place. For security reasons we cannot show it again.",
    NEVER_EXPIRES: "Never Expires",
    EXPIRES: "Expires",
    NO_EXPIRATION: "No Expiration",
    CREATE_ORGANIZATION: "Create Organization",
    ORGANIZATION: "Organization",
    ORGANIZATION_NAME: "Name",
    ORGANIZATION_NAME_PLACEHOLDER: "Acme Inc.",
    ORGANIZATION_NAME_DESCRIPTION: "This is your organization's visible name.",
    ORGANIZATION_NAME_INSTRUCTIONS: "Please use 32 characters at maximum.",
    ORGANIZATION_SLUG: "Slug URL",
    ORGANIZATION_SLUG_DESCRIPTION: "This is your organization's URL namespace.",
    ORGANIZATION_SLUG_INSTRUCTIONS: "Please use 48 characters at maximum.",
    ORGANIZATION_SLUG_PLACEHOLDER: "acme-inc",
    CREATE_ORGANIZATION_SUCCESS: "Organization created successfully",
    PASSWORD: "Password",
    PASSWORD_PLACEHOLDER: "Password",
    PASSWORD_REQUIRED: "Password is required",
    PASSWORDS_DO_NOT_MATCH: "Passwords do not match",
    PROVIDERS: "Providers",
    PROVIDERS_DESCRIPTION: "Connect your account with a third-party service.",
    RECOVER_ACCOUNT: "Recover Account",
    RECOVER_ACCOUNT_ACTION: "Recover account",
    RECOVER_ACCOUNT_DESCRIPTION: "Please enter a backup code to access your account",
    REMEMBER_ME: "Remember me",
    RESEND_CODE: "Resend code",
    RESEND_VERIFICATION_EMAIL: "Resend Verification Email",
    RESET_PASSWORD: "Reset Password",
    RESET_PASSWORD_ACTION: "Save new password",
    RESET_PASSWORD_DESCRIPTION: "Enter your new password below",
    RESET_PASSWORD_SUCCESS: "Password reset successfully",
    REQUEST_FAILED: "Request failed",
    REVOKE: "Revoke",
    DELETE_API_KEY: "Delete API Key",
    DELETE_API_KEY_CONFIRM: "Are you sure you want to delete this API key?",
    API_KEY: "API Key",
    SIGN_IN: "Sign In",
    SIGN_IN_ACTION: "Login",
    SIGN_IN_DESCRIPTION: "Enter your email below to login to your account",
    SIGN_IN_USERNAME_DESCRIPTION: "Enter your username or email to login to your account",
    SIGN_IN_WITH: "Sign in with",
    SIGN_OUT: "Sign Out",
    SIGN_UP: "Sign Up",
    SIGN_UP_ACTION: "Create an account",
    SIGN_UP_DESCRIPTION: "Enter your information to create an account",
    SIGN_UP_EMAIL: "Check your email for the verification link.",
    SESSIONS: "Sessions",
    SESSIONS_DESCRIPTION: "Manage your active sessions and revoke access.",
    SET_PASSWORD: "Set Password",
    SET_PASSWORD_DESCRIPTION: "Click the button below to receive an email to set up a password for your account.",
    SETTINGS: "Settings",
    SAVE: "Save",
    SECURITY: "Security",
    SWITCH_ACCOUNT: "Switch Account",
    TRUST_DEVICE: "Trust this device",
    TWO_FACTOR: "Two-Factor",
    TWO_FACTOR_ACTION: "Verify code",
    TWO_FACTOR_DESCRIPTION: "Please enter your one-time password to continue",
    TWO_FACTOR_CARD_DESCRIPTION: "Add an extra layer of security to your account.",
    TWO_FACTOR_DISABLE_INSTRUCTIONS: "Please enter your password to disable 2FA.",
    TWO_FACTOR_ENABLE_INSTRUCTIONS: "Please enter your password to enable 2FA.",
    TWO_FACTOR_ENABLED: "Two-factor authentication has been enabled",
    TWO_FACTOR_DISABLED: "Two-Factor Authentication has been disabled",
    TWO_FACTOR_PROMPT: "Two-Factor Authentication",
    TWO_FACTOR_TOTP_LABEL: "Scan the QR Code with your Authenticator",
    SEND_VERIFICATION_CODE: "Send verification code",
    UNLINK: "Unlink",
    UPDATED_SUCCESSFULLY: "updated successfully",
    USERNAME: "Username",
    USERNAME_DESCRIPTION: "Enter the username you want to use to log in.",
    USERNAME_INSTRUCTIONS: "Please use 32 characters at maximum.",
    USERNAME_PLACEHOLDER: "Username",
    OPTIONAL_BRACKETS: "(Optional)",
    SIGN_IN_USERNAME_PLACEHOLDER: "Username or email",
    VERIFY_YOUR_EMAIL: "Verify Your Email",
    VERIFY_YOUR_EMAIL_DESCRIPTION: "Please verify your email address. Check your inbox for the verification email. If you haven't received the email, click the button below to resend.",
    GO_BACK: "Go back",
    SESSION_NOT_FRESH: "Your session is not fresh. Please sign in again.",
    UPLOAD_AVATAR: "Upload Avatar",
    LOGO: "Logo",
    LOGO_DESCRIPTION: "Click on the logo to upload a custom one from your files.",
    LOGO_INSTRUCTIONS: "A logo is optional but strongly recommended.",
    UPLOAD: "Upload",
    UPLOAD_LOGO: "Upload Logo",
    DELETE_LOGO: "Delete Logo",
    PRIVACY_POLICY: "Privacy Policy",
    TERMS_OF_SERVICE: "Terms of Service",
    PROTECTED_BY_RECAPTCHA: "This site is protected by reCAPTCHA.",
    BY_CONTINUING_YOU_AGREE: "By continuing, you agree to the",
    USER: "User",
    ORGANIZATIONS: "Organizations",
    ORGANIZATIONS_DESCRIPTION: "Manage your organizations and memberships.",
    ORGANIZATIONS_INSTRUCTIONS: "Create an organization to collaborate with other users.",
    LEAVE_ORGANIZATION: "Leave Organization",
    LEAVE_ORGANIZATION_CONFIRM: "Are you sure you want to leave this organization?",
    LEAVE_ORGANIZATION_SUCCESS: "You have successfully left the organization.",
    MANAGE_ORGANIZATION: "Manage Organization",
    REMOVE_MEMBER: "Remove Member",
    REMOVE_MEMBER_CONFIRM: "Are you sure you want to remove this member from the organization?",
    REMOVE_MEMBER_SUCCESS: "Member removed successfully",
    INVITE_MEMBER: "Invite Member",
    MEMBERS: "Members",
    MEMBERS_DESCRIPTION: "Add or remove members and manage their roles.",
    MEMBERS_INSTRUCTIONS: "Invite new members to your organization.",
    INVITE_MEMBER_DESCRIPTION: "Send an invitation to add a new member to your organization.",
    ROLE: "Role",
    SELECT_ROLE: "Select a role",
    ADMIN: "Admin",
    MEMBER: "Member",
    GUEST: "Guest",
    OWNER: "Owner",
    UPDATE_ROLE_DESCRIPTION: "Update the role for this member",
    UPDATE_ROLE: "Update Role",
    MEMBER_ROLE_UPDATED: "Member role updated successfully",
    SEND_INVITATION: "Send Invitation",
    SEND_INVITATION_SUCCESS: "Invitation sent successfully",
    PENDING_INVITATIONS: "Pending Invitations",
    PENDING_INVITATIONS_DESCRIPTION: "Manage pending invitations to your organization.",
    PENDING_USER_INVITATIONS_DESCRIPTION: "Invitations you've received from organizations.",
    CANCEL_INVITATION: "Cancel Invitation",
    INVITATION_CANCELLED: "Invitation cancelled successfully",
    ACCEPT_INVITATION: "Accept Invitation",
    ACCEPT_INVITATION_DESCRIPTION: "You have been invited to join an organization.",
    INVITATION_ACCEPTED: "Invitation accepted successfully",
    INVITATION_REJECTED: "Invitation rejected successfully",
    ACCEPT: "Accept",
    REJECT: "Reject",
    INVITATION_EXPIRED: "This invitation has expired",
    DELETE_ORGANIZATION: "Delete Organization",
    DELETE_ORGANIZATION_DESCRIPTION: "Permanently remove your organization and all of its contents. This action is not reversible  please continue with caution.",
    DELETE_ORGANIZATION_SUCCESS: "Organization deleted successfully",
    DELETE_ORGANIZATION_INSTRUCTIONS: "Enter the organization slug to continue:",
    SLUG_REQUIRED: "Organization slug is required",
    SLUG_DOES_NOT_MATCH: "The slug does not match",
    TEAM: "Team",
    TEAMS: "Teams",
    TEAM_ACTIVE: "Active",
    TEAM_SET_ACTIVE: "Set Active",
    CREATE_TEAM: "Create Team",
    CREATE_TEAM_SUCCESS: "Team created successfully",
    UPDATE_TEAM: "Update Team",
    UPDATE_TEAM_DESCRIPTION: "Update the name for this team",
    REMOVE_TEAM_CONFIRM: "Are you sure you want to remove this team from the organization?",
    CREATE_TEAM_INSTRUCTIONS: "Add new team to your organization.",
    TEAM_NAME: "Team Name",
    TEAM_NAME_PLACEHOLDER: "Engineering Team",
    TEAM_NAME_DESCRIPTION: "This is your team's visible name.",
    TEAM_NAME_INSTRUCTIONS: "Please use 64 characters at maximum.",
    TEAMS_DESCRIPTION: "Manage your teams within your organization.",
    USER_TEAMS_DESCRIPTION: "You are a member of the following teams.",
    DELETE_TEAM: "Delete Team",
    DELETE_TEAM_DESCRIPTION: "Permanently remove this team and all of its contents.",
    DELETE_TEAM_SUCCESS: "Team deleted successfully",
    DELETE_TEAM_INSTRUCTIONS: "Enter the team name to continue:",
    TEAM_NAME_REQUIRED: "Team name is required",
    TEAM_NAME_DOES_NOT_MATCH: "The team name does not match",
    TEAM_MEMBERS: "Team Members",
    TEAM_MEMBERS_DESCRIPTION: "Manage your team members and their roles.",
    ADD_TEAM_MEMBER: "Add Team Member",
    REMOVE_TEAM_MEMBER: "Remove Team Member",
    REMOVE_TEAM_MEMBER_CONFIRM: "Are you sure you want to remove this member from the team?",
    REMOVE_TEAM_MEMBER_SUCCESS: "Team member removed successfully",
    ADD_TEAM_MEMBER_SUCCESS: "Team member added successfully",
    UPDATE_TEAM_SUCCESS: "Team updated successfully",
    MANAGE_TEAM_MEMBERS: "Manage Team Members",
    MANAGE_TEAM_MEMBERS_DESCRIPTION: "Search and add organization members to this team.",
    NO_TEAMS_FOUND: "No teams found",
    MEMBER_SINGULAR: "member",
    MEMBER_PLURAL: "members",
    UNKNOWN: "Unknown",
    ...BASE_ERROR_CODES,
    ...ADMIN_ERROR_CODES,
    ...ANONYMOUS_ERROR_CODES,
    ...API_KEY_ERROR_CODES,
    ...CAPTCHA_ERROR_CODES,
    ...EMAIL_OTP_ERROR_CODES,
    ...GENERIC_OAUTH_ERROR_CODES,
    ...HAVEIBEENPWNED_ERROR_CODES,
    ...MULTI_SESSION_ERROR_CODES,
    ...ORGANIZATION_ERROR_CODES,
    ...PASSKEY_ERROR_CODES,
    ...PHONE_NUMBER_ERROR_CODES,
    ...STRIPE_ERROR_CODES,
    ...TEAM_ERROR_CODES,
    ...TWO_FACTOR_ERROR_CODES,
    ...USERNAME_ERROR_CODES
};
var authViewPaths = {
    CALLBACK: "callback",
    EMAIL_OTP: "email-otp",
    FORGOT_PASSWORD: "forgot-password",
    MAGIC_LINK: "magic-link",
    RECOVER_ACCOUNT: "recover-account",
    RESET_PASSWORD: "reset-password",
    SIGN_IN: "sign-in",
    SIGN_OUT: "sign-out",
    SIGN_UP: "sign-up",
    TWO_FACTOR: "two-factor",
    ACCEPT_INVITATION: "accept-invitation"
};
var accountViewPaths = {
    SETTINGS: "settings",
    SECURITY: "security",
    TEAMS: "teams",
    API_KEYS: "api-keys",
    ORGANIZATIONS: "organizations"
};
var organizationViewPaths = {
    SETTINGS: "settings",
    MEMBERS: "members",
    TEAMS: "teams",
    API_KEYS: "api-keys"
};
;
}),
"[project]/node_modules/@neondatabase/auth/dist/ui-COLWzDsu.mjs [app-ssr] (ecmascript) <locals> <export M as NeonAuthUIProvider>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NeonAuthUIProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$ui$2d$COLWzDsu$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["M"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$ui$2d$COLWzDsu$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/ui-COLWzDsu.mjs [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/@neondatabase/auth/dist/ui-COLWzDsu.mjs [app-ssr] (ecmascript) <locals> <export d as AuthView>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuthView",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$ui$2d$COLWzDsu$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["d"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$neondatabase$2f$auth$2f$dist$2f$ui$2d$COLWzDsu$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@neondatabase/auth/dist/ui-COLWzDsu.mjs [app-ssr] (ecmascript) <locals>");
}),
];

//# sourceMappingURL=node_modules_%40neondatabase_auth_dist_bbf1629c._.js.map